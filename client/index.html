<div id="signUpDiv">
	name: <input id="signUpName" type="text"></input>
	<button id="signUpButton">Sign Up</button>
</div>

<div id="gameDiv" style="display:none;">
	<canvas id="ctx" width="800" height="500" style="border:1px solid #000000;"></canvas>
</div>

<script src="client/js/socket.io-1.4.5.js"></script>

<script>
	var socket = io(); 
	
	//Sign up 
	var signUpDiv = document.getElementById("signUpDiv"); 
	var signUpName = document.getElementById("signUpName"); 
	var signUpButton = document.getElementById("signUpButton"); 
	var gameDiv = document.getElementById("gameDiv"); 
	
	signUpButton.onclick = function(){
		socket.emit('signUp', {name:signUpName.value}); 
	}; 
	
	//Canvas setting 
	var wholeCanvas; 
	var mainMap; 
	var mapInfo; 
	var myStatusBar; 
	
	var cvs = document.getElementById("ctx"); 
	var ctx = cvs.getContext("2d"); 
	ctx.font = '10px Arial'; 
	
	//Game objects 
	
	class Status {
		constructor() {
			this.speedLevels = ['reverse', 'stop', 'half', 'full']
			this.speedLevelIndex = 1; 
			this.rudderLock = 'straight'; // Can also take value 'left' or 'right', which evaluate to boolean true 
			this.currentSpeedFrac = 0; 
			this.currentRudderFrac = 0; 
		}
		update(currentSpeedFrac, currentRudderFrac) {
			this.currentSpeedFrac = currentSpeedFrac; 
			this.currentRudderFrac = currentRudderFrac; 
		}
	}; 
	var myStatus = new Status(); 
	
	class Entity {
		constructor(position, bearing) {
			this.position = position; 
			this.bearing = bearing; 
		}
		draw(scale) {}
		dummyDraw() {}
	}; 
	
	class Ship extends Entity {
		constructor(name, position, bearing) {
			super(position, bearing); 
			this.name = name; 
		}
		update(position, bearing) {
			this.position = position; 
			this.bearing = bearing; 
		}
		draw(scale, displayType, scopeType, displayFrameSize, myPosition, drawingMe) {
			if (scopeType != 'centered' || (Math.abs(this.position.x-myPosition.x) <= displayFrameSize.width/scale/2 && Math.abs(this.position.y-myPosition.y) <= displayFrameSize.height/scale/2)) {
				if (displayType === 'detailed') {
					ctx.transform(1/scale, 0, 0, -1/scale, this.position.x, this.position.y); 
					ctx.fillStyle = 'black'; 
					ctx.fillText(this.name, 0, -10); 
					ctx.transform(scale, 0, 0, -scale, 0, 0); 
					
					ctx.strokeStyle="black";
					ctx.transform(Math.cos(this.bearing), Math.sin(this.bearing), -Math.sin(this.bearing), Math.cos(this.bearing), 0, 0); 
					ctx.lineWidth=100;
					ctx.beginPath();
					ctx.moveTo(0, 0); 
					ctx.lineTo(-100,0);
					ctx.stroke();
					ctx.lineWidth=50;
					ctx.beginPath();
					ctx.moveTo(0,0); 
					ctx.lineTo(100,0);
					ctx.stroke();
				}
				else if (displayType === 'dummy') {
					if (drawingMe) {ctx.fillStyle = 'green'; }
					else {ctx.fillStyle = 'white'; }
					ctx.fillRect(this.position.x-2/scale, this.position.y-2/scale, 4/scale, 4/scale); 
				}
			}
		}
		static updateList(newShipList) {
			for(let shipName in Ship.list) {
				if (!(shipName in newShipList)){
					delete Ship.list[shipName]; 
				}
			}
			for(let shipName in newShipList) {
				if (shipName in Ship.list) {
					Ship.list[shipName].update(newShipList[shipName].position, newShipList[shipName].bearing); 
				}
				else {
					var ship = new Ship(shipName, newShipList[shipName].position, newShipList[shipName].bearing); 
					Ship.list[shipName] = ship; 
				}
			}
		}
	}; 
	Ship.list = {}; 
	
	//Canvas objects 
	
	class CanvasComponent {
		constructor(position, size, color) {
			CanvasComponent.list.push(this); 
			this.position = position; // position = {x, y} 
			this.size = size; // size = {width, height} 
			this.color = color; 
		}
		setTransform() {
			ctx.setTransform(1, 0, 0, 1, this.position.x, this.position.y); 
		} // set you up for drawing
		draw() { 
			ctx.fillStyle = this.color;
			ctx.setTransform(1, 0, 0, 1, 0, 0); 
			ctx.fillRect(this.position.x, this.position.y, this.size.width, this.size.height); // clear the component 
			this.setTransform(); 
		}
	}; 
	CanvasComponent.list = []; // This is really a list, made to draw in the right order 
	
	class MapComponent extends CanvasComponent {
		constructor(position, size, myShip, scale, color, displayType, scopeType, grid) {
			super(position, size, color); 
			if (scopeType === 'whole') {
				this.size = {width:mapInfo.size.x*scale, height:mapInfo.size.y*scale}; 
			}
			this.scale = scale; 
			this.myShipName = myShip.name; 
			this.myPosition = {x:mapInfo.size.x/2, y:mapInfo.size.y/2}; 
			this.displayType = displayType; 
			this.scopeType = scopeType; 
			this.grid = grid; 
		}
		setTransform() {
			ctx.setTransform(this.scale, 0, 0, -this.scale, this.position.x+this.size.width/2, this.position.y + this.size.height/2);
			ctx.transform(1, 0, 0, 1, -this.myPosition.x, -this.myPosition.y);
		}
		drawGrid() {
			if (this.grid > 1) {
				this.setTransform(); 
				for(let i = Math.max(Math.ceil((this.myPosition.x - this.size.width/this.scale/2)/(mapInfo.size.x/this.grid))*(mapInfo.size.x/this.grid), 0); i <= Math.min((this.myPosition.x + this.size.width/this.scale/2), mapInfo.size.x); i += (mapInfo.size.x/this.grid)) {
					ctx.lineWidth=2/this.scale;
					ctx.strokeStyle="grey";
					ctx.beginPath();
					ctx.moveTo(i, Math.max(this.myPosition.y - this.size.height/this.scale/2, 0)); 
					ctx.lineTo(i, Math.min(this.myPosition.y + this.size.height/this.scale/2, mapInfo.size.y));
					ctx.stroke();
				}
				for(let i = Math.max(Math.ceil((this.myPosition.y - this.size.height/this.scale/2)/(mapInfo.size.y/this.grid))*(mapInfo.size.y/this.grid), 0); i <= Math.min((this.myPosition.y + this.size.height/this.scale/2), mapInfo.size.y); i += (mapInfo.size.y/this.grid)) {
					ctx.lineWidth=2/this.scale;
					ctx.strokeStyle="grey";
					ctx.beginPath();
					ctx.moveTo(Math.max(this.myPosition.x - this.size.width/this.scale/2, 0), i); 
					ctx.lineTo(Math.min(this.myPosition.x + this.size.width/this.scale/2, mapInfo.size.x), i);
					ctx.stroke();
				}
			}
		}
		draw() {
			super.draw(); 
			if (this.scopeType === 'centered') {this.myPosition = Ship.list[this.myShipName].position; } 
			
			//draw grid 
			this.drawGrid(); 
			
			//draw ships 
			for(let name in Ship.list) {
				this.setTransform(); 
				Ship.list[name].draw(this.scale, this.displayType, this.scopeType, this.size, this.myPosition, (name === this.myShipName)); 
			}
		}
	}; 
	
		class SpeedBar extends CanvasComponent {
		constructor(position, status) {
			super(position, {width:100, height:100}, 'white')
			this.rudderLockDic = {'left': -this.size.width/2, 'straight': 0, 'right': this.size.width/2}; 
			this.speedLockDic = {'full': 4*this.size.height/5, 'half': 2*this.size.height/5, 'stop': 0, 'reverse': -this.size.height/5}; 
			this.status = status; 
		}
		setTransform() {
			ctx.setTransform(1, 0, 0, -1, this.position.x + this.size.width/2, this.position.y + 4*this.size.height/5); 
		} // set you up for drawing
		draw() {
			super.draw(); 
			ctx.strokeStyle="black";
			ctx.lineWidth=5;
			ctx.beginPath();
			ctx.moveTo(this.rudderLockDic['left'], 0); 
			ctx.lineTo(this.rudderLockDic['right'], 0);
			ctx.stroke();
			ctx.beginPath();
			ctx.moveTo(0, this.speedLockDic['full']); 
			ctx.lineTo(0, this.speedLockDic['reverse']);
			ctx.stroke();
			ctx.fillStyle = 'red';
			ctx.fillRect(this.rudderLockDic[this.status.rudderLock]-5, this.speedLockDic[this.status.speedLevels[this.status.speedLevelIndex]]-5, 10, 10); 
			ctx.fillStyle = 'blue';
			ctx.fillRect(this.rudderLockDic['left']*this.status.currentRudderFrac-5, this.speedLockDic['full']*this.status.currentSpeedFrac-5, 10, 10); 
		}
	}; 
	
	class StatusBar extends CanvasComponent {
		constructor(position, status) {
			super(position, {width:100, height:500}, 'white'); 
			this.status = status; 
			this.Speedbar = new SpeedBar({x:this.position.x, y:this.position.y+350}, this.status); 
		}
		draw() {
			this.Speedbar.draw(); 
		}
	}; 
	
	// Socket package handling 
	// Signup response 
	socket.on('signUpResponse', function(data){
		if (data.success){
			signUpDiv.style.display = 'none'; 
			mapInfo = data.mapInfo; 
			myStatus = new Status(); 
			wholeCanvas = new CanvasComponent({x:0,y:0}, {width:800, height:500}, 'white'); 
			myStatusBar = new StatusBar({x:100, y:0}, myStatus); 
			mainMap = new MapComponent({x:200, y:0}, {width:500, height:500}, data.myShip, 1/10, '#AED6F1', 'detailed', 'centered', 10); 
			miniMap = new MapComponent({x:200, y:0}, undefined, data.myShip, 1/100, 'black', 'dummy', 'whole', 0); 
			gameDiv.style.display = 'inline-block'; 
		} 
		else {alert(data.msg); }
	}); 
	
	// Update frame 
	socket.on('updateFrame', function(data){
		// data is composed of: 
		// a dictionary detectedShipList, with entries name:{position: {x, y}, bearing} 
		// a dictionary myShip = {currentSpeedFrac, currentRudderFrac} 
		
		// update 
		myStatus.update(data.myShip.currentSpeedFrac, data.myShip.currentRudderFrac); 
		Ship.updateList(data.detectedShipInfoList); 
		
		// draw 
		for(let i=0; i < CanvasComponent.list.length; i++) {
			CanvasComponent.list[i].draw(); 
		}
		ctx.setTransform(1, 0, 0, 1, 0, 0); 
		ctx.fillText('Speed = ' + myStatus.speedLevels[myStatus.speedLevelIndex], 0, 10); 
		ctx.fillText('Rudder = ' + myStatus.rudderLock, 0, 20); 
	}); 
	
	// Control handling 
	document.onkeydown = function(event){
		if (event.keyCode === 65) {// On pressing 'a' 
			myStatus.rudderLock = 'left'; 
			socket.emit('rudderShift', 'left'); 
		} 
		else if (event.keyCode === 68) {
			myStatus.rudderLock = 'right'; 
			socket.emit('rudderShift', 'right'); 
		} 
		else if (event.keyCode === 81) {
			if (myStatus.rudderLock === 'right') {
				myStatus.rudderLock = 'straight'; 
				socket.emit('rudderShift', 'straight'); 
			}
			else {
				myStatus.rudderLock = 'left'; 
				socket.emit('rudderShift', 'left'); 
			}
		} 
		else if (event.keyCode === 69) {
			if (myStatus.rudderLock === 'left') {
				myStatus.rudderLock = 'straight'; 
				socket.emit('rudderShift', 'straight'); 
			}
			else {
				myStatus.rudderLock = 'right'; 
				socket.emit('rudderShift', 'right'); 
			}
		} 
		else if (event.keyCode === 87) {
			myStatus.speedLevelIndex = Math.min(myStatus.speedLevelIndex + 1, 3)
			socket.emit('speedChange', myStatus.speedLevels[myStatus.speedLevelIndex]); 
		} 
		else if (event.keyCode === 83) {
			myStatus.speedLevelIndex = Math.max(myStatus.speedLevelIndex - 1, 0)
			socket.emit('speedChange', myStatus.speedLevels[myStatus.speedLevelIndex]); 
		} 
	}; 
	
	document.onkeyup = function(event){
		if (event.keyCode === 65) {
			myStatus.rudderLock = 'straight'; 
			socket.emit('rudderShift', 'straight'); 
		} 
		else if (event.keyCode === 68) {
			myStatus.rudderLock = 'straight'; 
			socket.emit('rudderShift', 'straight'); 
		} 
	}; 
</script>