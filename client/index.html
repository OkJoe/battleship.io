<div id="signUpDiv">
	name: <input id="signUpName" type="text"></input>
	<button id="signUpButton">Sign Up</button>
</div>

<div id="gameDiv" style="display:none;">
	<canvas id="ctx" width="1000" height="500" style="border:1px solid #000000;"></canvas>
</div>

<script src="client/js/socket.io-1.4.5.js"></script>

<script>
	var socket = io(); 
	function mod(a,b) {
		return (a%b+b)%b; 
	}; 
	
	//Sign up 
	var signUpDiv = document.getElementById("signUpDiv"); 
	var signUpName = document.getElementById("signUpName"); 
	var signUpButton = document.getElementById("signUpButton"); 
	var gameDiv = document.getElementById("gameDiv"); 
	
	signUpButton.onclick = function(){
		socket.emit('signUp', {name:signUpName.value}); 
	}; 
	
	//Canvas setting 
	var wholeCanvas; 
	var mainMap; 
	var miniMap; 
	var scope; 
	var mapInfo; 
	var privateStatusBar; 
	var myStatusBar; 
	var enemyStatusBar; 
	var LMBStatus = {
		position: {x: 0, y: 0}, 
		lastMouseDownPosition: {x: 0, y: 0}, 
		pressed: false, 
		shift: false, 
		update: function(x, y, pressed) {
			this.position.x = x; 
			this.position.y = y; 
			if (pressed && !this.pressed) {
				this.lastMouseDownPosition = {x, y}; 
			}
			this.pressed = pressed; 
		}
	}; 
	
	var cvs = document.getElementById("ctx"); 
	var ctx = cvs.getContext("2d"); 
	ctx.font = '15px Arial'; 
	
	//Game objects 
	
	class Status {
		constructor() {
			this.speedLevels = ['reverse', 'stop', 'half', 'full']
			this.speedLevelIndex = 1; 
			this.rudderLock = 'straight'; // Can also take value 'left' or 'right', which evaluate to boolean true 
			this.currentSpeedFrac = 0; 
			this.currentRudderFrac = 0; 
			this.name = undefined; 
			this.weapons = ['???', 'gun', 'torpedolauncher', 'minelayer']; 
			this.selectedWeaponIndex = 1; 
			this.torpedoSpreadOptions = {'narrow': 0.07, 'wide': 0.2}; 
			this.aimDirection = 0; 
			this.torpedoSpread = 'narrow'; 
			this.selectedTorpedoLauncherComponentId = 0; 
			this.levels = undefined; 
		}
		update(shipData) {
			this.currentSpeedFrac = shipData.currentSpeedFrac; 
			this.currentRudderFrac = shipData.currentRudderFrac; 
			this.levels = shipData.levels; 
		} 
		findNextTorpedoLauncher() {
			if (this.name in Ship.list) {
			for (let i = this.selectedTorpedoLauncherComponentId + 1; i < Ship.list[this.name].components.length + this.selectedTorpedoLauncherComponentId; i++) {
				for (let j = 0; j < Ship.list[this.name].components[i%Ship.list[this.name].components.length].modules.length; j++) {
					if (Ship.list[this.name].components[i%Ship.list[this.name].components.length].modules[j].type === 'torpedolauncher') {
						if (Ship.list[this.name].components[i%Ship.list[this.name].components.length].modules[j].reloadCountDown === 0) {
							this.selectedTorpedoLauncherComponentId = i%Ship.list[this.name].components.length; 
							return; 
						}
					}
				}
			}
			for (let i = this.selectedTorpedoLauncherComponentId; i < Ship.list[this.name].components.length + this.selectedTorpedoLauncherComponentId; i++) {
				for (let j = 0; j < Ship.list[this.name].components[i%Ship.list[this.name].components.length].modules.length; j++) {
					if (Ship.list[this.name].components[i%Ship.list[this.name].components.length].modules[j].type === 'torpedolauncher') {
							this.selectedTorpedoLauncherComponentId = i%Ship.list[this.name].components.length; 
							return; 
					}
				}
			}
			}
		}
	}; 
	var myStatus = new Status(); 
	
	class Entity {
		constructor(position, bearing) {
			this.position = position; 
			this.bearing = bearing; 
		}
		isInMapScope(scale, displayFrameSize, mapCenterPosition) {
			if (Math.abs(this.position.x-mapCenterPosition.x) <= displayFrameSize.width/scale/2 && Math.abs(this.position.y-mapCenterPosition.y) <= displayFrameSize.height/scale/2) {
				return true; 
			}
			else {return false; }
		}
		draw(scale) {}
	}; 
	
	class Weapon extends Entity {
		constructor(position, activationTimer, bearing) {
			super(position, bearing); 
			this.activationTimer = activationTimer; 
		} 
		drawShape(scale, color) {
			ctx.fillStyle = color; 
			ctx.fillRect(this.position.x-2/scale, this.position.y-2/scale, 4/scale, 4/scale); 
		} 
		draw(scale, displayFrameSize, myPosition) {
			if (this.isInMapScope(scale, displayFrameSize, myPosition)) {
				var color; 
				if (this.activationTimer === 0) {
					color = 'red'; 
				}
				else {
					color = 'white'; 
				}
				this.drawShape(scale, color); 
			}
		} 
		static update(newList) {
			for(let id in this.list) {
				if (!(id in newList)){
					delete this.list[id]; 
				}
			}
			for(let id in newList) {
				if (!(id in this.list)) {
					this.list[id] = new this(newList[id].position, newList[id].activationTimer, newList[id].direction); 
				}
				else {
					this.list[id].position = newList[id].position; 
					this.list[id].activationTimer = newList[id].activationTimer; 
					this.list[id].bearing = newList[id].direction; 
				}
			}
		} 
	} 
	
	class Mine extends Weapon {
		constructor(position, activationTimer) {
			super(position, activationTimer, undefined); 
		} 
	} 
	Mine.list = {}; 
	
	class Torpedo extends Weapon {
		constructor(position, activationTimer, bearing) {
			super(position, activationTimer, bearing); 
		} 
		drawShape(scale, color) {
			ctx.lineWidth=3/scale;
			ctx.strokeStyle = color;
			ctx.beginPath();
			ctx.moveTo(this.position.x, this.position.y); 
			ctx.lineTo(this.position.x - Math.cos(this.bearing)*10/scale, this.position.y - Math.sin(this.bearing)*10/scale);
			ctx.stroke(); 
		} 
	} 
	Torpedo.list = {}; 
	
	class Shell extends Weapon {
		constructor(position, activationTimer) {
			super(position, activationTimer, undefined); 
		} 
		draw(scale, displayFrameSize, myPosition) {
			if (this.isInMapScope(scale, displayFrameSize, myPosition)) {
				var color; 
				var fadeTime = 3; 
				var SparkTime = 0.2; 
				if (this.activationTimer >= -SparkTime) {
					color = 'rgba(255,0,0,' + Math.min(Math.max(1 - this.activationTimer/fadeTime, 0), 1) + ')'; 
				}
				else {
					color = 'rgba(255,255,255,' + Math.min(this.activationTimer/fadeTime + 1, 1) + ')'; 
				}
				this.drawShape(scale, color); 
			}
		} 
	} 
	Shell.list = {}; 
	
	class Ship extends Entity {
		constructor(name, position, bearing, components, size) {
			super(position, bearing); 
			this.components = components; 
			this.name = name; // Maybe delete this 
			this.size = size; 
		}
		update(position, bearing, components, size) {
			this.position = position; 
			this.bearing = bearing; 
			this.components = components; 
			this.size = size; 
		}
		draw(scale, displayType, scopeType, displayFrameSize, myPosition, drawingMe, showName, bearingAhead, showDmg) {
			var drawShip = true; 
			if (scopeType === 'centered') {
				drawShip = this.isInMapScope(scale, displayFrameSize, myPosition); 
			} 
			if (drawShip) {
				if (displayType === 'detailed') {
					if (showName) {
						ctx.transform(1/scale, 0, 0, -1/scale, this.position.x, this.position.y); 
						ctx.fillStyle = 'black'; 
						ctx.fillText(this.name, -5, -15); 
						ctx.transform(scale, 0, 0, -scale, 0, 0); 
					}
					else {ctx.transform(1, 0, 0, 1, this.position.x, this.position.y); }
					
					/*
					if (bearingRelMyShip) {
						var relVectorLength = Math.sqrt((this.position.x - Ship.list[myStatus.name].position.x)*(this.position.x - Ship.list[myStatus.name].position.x) + (this.position.y - Ship.list[myStatus.name].position.y)*(this.position.y - Ship.list[myStatus.name].position.y)); 
						if (relVectorLength === 0) {
							ctx.transform(0, 1, -1, 0, 0, 0);
						}
						else {
							var relVectorCos = (this.position.x - Ship.list[myStatus.name].position.x)/relVectorLength; 
							var relVectorSin = (this.position.y - Ship.list[myStatus.name].position.y)/relVectorLength; 
							ctx.transform(Math.cos(this.bearing), Math.sin(this.bearing), -Math.sin(this.bearing), Math.cos(this.bearing), 0, 0); 
							ctx.transform(relVectorCos, -relVectorSin, relVectorSin, relVectorCos, 0, 0); 
							ctx.transform(0, 1, -1, 0, 0, 0); 
						}
					}*/
					
					if (bearingAhead) {
						ctx.transform(0, 1, -1, 0, 0, 0); 
					}
					
					else {ctx.transform(Math.cos(this.bearing), Math.sin(this.bearing), -Math.sin(this.bearing), Math.cos(this.bearing), 0, 0); } 
					for (let i = 0; i < this.components.length; i++) {
						if (showDmg) {ctx.fillStyle = 'rgb(' + Math.floor(255 - this.components[i].HP*255/5) + ', 0, 0)'; }
						else {ctx.fillStyle = 'black'; } 
						if (this.components[i].shape.type === 'polygon') {
							ctx.transform(1, 0, 0, 1, this.components[i].position.x, this.components[i].position.y); 
							ctx.beginPath();
							ctx.moveTo(this.components[i].shape.vertices[0].x, this.components[i].shape.vertices[0].y); 
							for (let j = 1; j < this.components[i].shape.vertices.length; j++) {
								ctx.lineTo(this.components[i].shape.vertices[j].x, this.components[i].shape.vertices[j].y);
							}
							ctx.closePath(); 
							ctx.fill(); 
							ctx.transform(1, 0, 0, 1, -this.components[i].position.x, -this.components[i].position.y); 
						} 
						for (let j = 0; j < this.components[i].modules.length; j++) {
							drawModule[this.components[i].modules[j].type](this.components[i].position, myStatus.aimDirection); 
						}
					}
				}
				else if (displayType === 'dummy') {
					if (drawingMe) {ctx.fillStyle = 'green'; }
					else {ctx.fillStyle = 'white'; }
					ctx.fillRect(this.position.x-2/scale, this.position.y-2/scale, 4/scale, 4/scale); 
				}
			}
		}
		static update(newShipList) {
			for(let shipName in Ship.list) {
				if (!(shipName in newShipList)){
					delete Ship.list[shipName]; 
				}
			}
			for(let shipName in newShipList) {
				if (shipName in Ship.list) {
					Ship.list[shipName].update(newShipList[shipName].position, newShipList[shipName].bearing, newShipList[shipName].components, newShipList[shipName].size); 
				}
				else {
					var ship = new Ship(shipName, newShipList[shipName].position, newShipList[shipName].bearing, newShipList[shipName].components, newShipList[shipName].size); 
					Ship.list[shipName] = ship; 
				}
			}
		}
	}; 
	Ship.list = {}; 
	
	//Canvas objects 
	
	var drawModule = {
		gun: function(position, direction, size = Ship.list[myStatus.name].size*0.4) {
			var multiplicity = myStatus.levels.gunmult; 
			ctx.transform(Math.cos(direction), Math.sin(direction), -Math.sin(direction), Math.cos(direction), position.x, position.y); 
			ctx.fillStyle = 'yellow'; 
			ctx.beginPath(); 
			ctx.arc(0, 0, size*(1/3+multiplicity/6), Math.PI*multiplicity/8, 2*Math.PI - Math.PI*multiplicity/8); 
			ctx.closePath(); 
			ctx.fill(); 
			ctx.strokeStyle="yellow"; 
			ctx.lineWidth = 10;
			for (let i = - size * (multiplicity/4-1/4); i < size * (multiplicity/4); i += 2 * size/4) {
				ctx.beginPath(); 
				ctx.moveTo(0, i); 
				ctx.lineTo(size, i); 
				ctx.stroke(); 
			}
			ctx.transform(Math.cos(direction), -Math.sin(direction), Math.sin(direction), Math.cos(direction), 0, 0); 
			ctx.transform(1, 0, 0, 1, -position.x, -position.y); 
		}, 
		torpedolauncher: function(position, direction, size = Ship.list[myStatus.name].size*0.4) {
			var multiplicity = myStatus.levels.torpmult; 
			ctx.transform(Math.cos(direction), Math.sin(direction), -Math.sin(direction), Math.cos(direction), position.x, position.y); 
			ctx.fillStyle = 'blue'; 
			ctx.beginPath(); 
			ctx.arc(-size/10, 0, size, Math.PI*1/3, Math.PI*2/3); 
			ctx.arc(-size/10, 0, size, Math.PI*4/3, Math.PI*5/3); 
			ctx.closePath(); 
			ctx.fill(); 
			ctx.strokeStyle="blue"; 
			ctx.lineWidth = 10;
			for (let i = - size + size/multiplicity; i < size; i += 2 * size/multiplicity) {
				ctx.beginPath(); 
				ctx.moveTo(-size, i*0.8); 
				ctx.lineTo(size, i*0.8); 
				ctx.stroke(); 
			}
			ctx.transform(Math.cos(direction), -Math.sin(direction), Math.sin(direction), Math.cos(direction), 0, 0); 
			ctx.transform(1, 0, 0, 1, -position.x, -position.y); 
		}, 
		minelayer: function(){}, 
		engine: function(){}, 
		showAll: {
			gun: function() {
				drawModule.gun({x:0, y:0}, Math.PI/2, 40); 
			}, 
			torpedolauncher: function() {
				drawModule.torpedolauncher({x:0, y:0}, Math.PI/2, 40); 
			}, 
			minelayer: function() {
				var size = 40; 
				ctx.fillStyle = '#AED6F1'; 
				ctx.beginPath(); 
				ctx.arc(0, 0, size, Math.PI*4/3, Math.PI*5/3); 
				ctx.arc(0, size*1.4, size, Math.PI*5/3, Math.PI*4/3, true); 
				ctx.closePath(); 
				ctx.fill(); 
				ctx.beginPath(); 
				ctx.arc(0, 0, size, Math.PI*1/3, Math.PI*2/3); 
				ctx.arc(0, size*1.5, size, Math.PI*4/3, Math.PI*5/3); 
				ctx.closePath(); 
				ctx.fill(); 
			}, 
			engine: function() {
				var size = 40; 
				ctx.fillStyle = 'white'; 
				var drawLobe = function (angle) {
					ctx.beginPath(); 
					ctx.arc(Math.cos(angle)*size*2/3, Math.sin(angle)*size*2/3, size*0.6, angle-0.1, Math.PI+angle-0.1); 
					ctx.closePath(); 
					ctx.fill(); 
				}; 
				[Math.PI/6, Math.PI*5/6, Math.PI*9/6].map(angle => drawLobe(angle)); 
			}
		}
	}; 
	
	class CanvasComponent {
		constructor(position, size, color) {
			CanvasComponent.list.push(this); 
			this.position = position; // position = {x, y} 
			this.size = size; // size = {width, height} 
			this.color = color; 
		}
		setTransform() {
			ctx.setTransform(1, 0, 0, 1, this.position.x, this.position.y); 
		} // set you up for drawing
		draw() { 
			ctx.fillStyle = this.color;
			ctx.setTransform(1, 0, 0, 1, 0, 0); 
			ctx.fillRect(this.position.x, this.position.y, this.size.width, this.size.height); // clear the component 
			this.setTransform(); 
		}
		isClickingMe(position) {
			if (position.x <= this.position.x) {
				return false; 
			}
			else if (position.x >= this.position.x + this.size.width) {
				return false; 
			}
			else if (position.y <= this.position.y) {
				return false; 
			}
			else if (position.y >= this.position.y + this.size.height) {
				return false; 
			}
			return true; 
		}
		onClick(position, event) {
			if (this.isClickingMe(position, event)) {
				// Do something 
			}
		}
	}; 
	CanvasComponent.list = []; // This is really a list, made to draw in the right order 
	
	class MapComponent extends CanvasComponent {
		constructor(position, size, myShipName, scale, color, displayType, scopeType, grid, showName, drawWeapon) {
			super(position, size, color); 
			if (scopeType === 'whole') {
				this.size = {width:mapInfo.size.x*scale, height:mapInfo.size.y*scale}; 
			}
			this.scale = scale; 
			this.myShipName = myShipName; 
			this.myPosition = {x:mapInfo.size.x/2, y:mapInfo.size.y/2}; 
			this.displayType = displayType; 
			this.scopeType = scopeType; 
			this.grid = grid; 
			this.showName = showName; 
			this.drawWeapon = drawWeapon; 
			this.show = true; 
		}
		setTransform() {
			ctx.setTransform(this.scale, 0, 0, -this.scale, this.position.x + this.size.width/2, this.position.y + this.size.height/2);
			ctx.transform(1, 0, 0, 1, -this.myPosition.x, -this.myPosition.y);
		}
		drawGrid() {
			if (this.grid > 1) {
				this.setTransform(); 
				for(let i = Math.max(Math.ceil((this.myPosition.x - this.size.width/this.scale/2)/(mapInfo.size.x/this.grid))*(mapInfo.size.x/this.grid), 0); i <= Math.min((this.myPosition.x + this.size.width/this.scale/2), mapInfo.size.x); i += (mapInfo.size.x/this.grid)) {
					ctx.lineWidth=2/this.scale;
					ctx.strokeStyle="grey";
					ctx.beginPath();
					ctx.moveTo(i, Math.max(this.myPosition.y - this.size.height/this.scale/2, 0)); 
					ctx.lineTo(i, Math.min(this.myPosition.y + this.size.height/this.scale/2, mapInfo.size.y));
					ctx.stroke();
				}
				for(let i = Math.max(Math.ceil((this.myPosition.y - this.size.height/this.scale/2)/(mapInfo.size.y/this.grid))*(mapInfo.size.y/this.grid), 0); i <= Math.min((this.myPosition.y + this.size.height/this.scale/2), mapInfo.size.y); i += (mapInfo.size.y/this.grid)) {
					ctx.lineWidth=2/this.scale;
					ctx.strokeStyle="grey";
					ctx.beginPath();
					ctx.moveTo(Math.max(this.myPosition.x - this.size.width/this.scale/2, 0), i); 
					ctx.lineTo(Math.min(this.myPosition.x + this.size.width/this.scale/2, mapInfo.size.x), i);
					ctx.stroke();
				}
			}
		}
		drawTorpedoTubeLines()	{
			if (myStatus.weapons[myStatus.selectedWeaponIndex] === 'torpedolauncher' && this.displayType === 'detailed') {
			var hasTorp = false; 
			var torpModNumber = -1; 
			for (let i = 0; i < Ship.list[this.myShipName].components[myStatus.selectedTorpedoLauncherComponentId].modules.length; i++) {
				if (Ship.list[this.myShipName].components[myStatus.selectedTorpedoLauncherComponentId].modules[i].type === 'torpedolauncher') {
					hasTorp = true; 
					torpModNumber = i; 
				}
			}
			if (hasTorp) {
				this.setTransform(); 
				var torpCpntPos = {x:Ship.list[myStatus.name].components[myStatus.selectedTorpedoLauncherComponentId].position.x, y:Ship.list[myStatus.name].components[myStatus.selectedTorpedoLauncherComponentId].position.y}; 
				torpCpntPos = {x:torpCpntPos.x*Math.cos(Ship.list[myStatus.name].bearing)-torpCpntPos.y*Math.sin(Ship.list[myStatus.name].bearing), y:torpCpntPos.x*Math.sin(Ship.list[myStatus.name].bearing)+torpCpntPos.y*Math.cos(Ship.list[myStatus.name].bearing)}; 
				var range = 1000; 
				ctx.lineWidth=4/this.scale;
				ctx.strokeStyle="white"; 
				ctx.beginPath();
				ctx.moveTo(this.myPosition.x + torpCpntPos.x, this.myPosition.y + torpCpntPos.y); 
				ctx.lineTo(this.myPosition.x + torpCpntPos.x + Math.cos(myStatus.aimDirection + Ship.list[myStatus.name].bearing)*range, this.myPosition.y + torpCpntPos.y + Math.sin(myStatus.aimDirection + Ship.list[myStatus.name].bearing)*range); 
				ctx.stroke();
				if (Ship.list[myStatus.name].components[myStatus.selectedTorpedoLauncherComponentId].modules[torpModNumber].reloadCountDown === 0) {
					ctx.strokeStyle="green"; 
				}
				else {
					ctx.strokeStyle="red"; 
				}
				ctx.beginPath();
				ctx.moveTo(this.myPosition.x + torpCpntPos.x, this.myPosition.y + torpCpntPos.y); 
				ctx.lineTo(this.myPosition.x + torpCpntPos.x + Math.cos(myStatus.aimDirection + Ship.list[myStatus.name].bearing + myStatus.torpedoSpreadOptions[myStatus.torpedoSpread]*(myStatus.levels.torpmult-1)/2)*range, this.myPosition.y + torpCpntPos.y + Math.sin(myStatus.aimDirection + Ship.list[myStatus.name].bearing + myStatus.torpedoSpreadOptions[myStatus.torpedoSpread]*(myStatus.levels.torpmult-1)/2)*range); 
				ctx.stroke();
				ctx.beginPath();
				ctx.moveTo(this.myPosition.x + torpCpntPos.x, this.myPosition.y + torpCpntPos.y); 
				ctx.lineTo(this.myPosition.x + torpCpntPos.x + Math.cos(myStatus.aimDirection + Ship.list[myStatus.name].bearing - myStatus.torpedoSpreadOptions[myStatus.torpedoSpread]*(myStatus.levels.torpmult-1)/2)*range, this.myPosition.y + torpCpntPos.y + Math.sin(myStatus.aimDirection + Ship.list[myStatus.name].bearing - myStatus.torpedoSpreadOptions[myStatus.torpedoSpread]*(myStatus.levels.torpmult-1)/2)*range); 
				ctx.stroke();
			}
			}
		}
		draw() {
			super.draw(); 
			if (this.show) {
				if (this.scopeType === 'centered') {this.myPosition = Ship.list[this.myShipName].position; } 
			
				//draw grid 
				this.drawGrid(); 
			
				//draw torpedo tube lines 
				this.onHover(); 
				this.drawTorpedoTubeLines(); 
			
				//draw ships 
				for(let name in Ship.list) {
					this.setTransform(); 
					Ship.list[name].draw(this.scale, this.displayType, this.scopeType, this.size, this.myPosition, (name === this.myShipName), this.showName, false); 
				}
			
				//draw weapons 
				if (this.drawWeapon) {
					for(let id in Mine.list) {
						this.setTransform(); 
						Mine.list[id].draw(this.scale, this.size, this.myPosition); 
					}
					for(let id in Torpedo.list) {
						this.setTransform(); 
						Torpedo.list[id].draw(this.scale, this.size, this.myPosition); 
					}
					for(let id in Shell.list) {
						this.setTransform(); 
						Shell.list[id].draw(this.scale, this.size, this.myPosition); 
					}
				}
			}
		}
		cvtFromCvsToMap(position) {
			var positionInMap = {x:position.x, y:position.y}; 
			positionInMap.x -= (this.position.x + this.size.width/2); 
			positionInMap.y = this.position.y - positionInMap.y + this.size.height/2; 
			positionInMap.x /= this.scale; 
			positionInMap.y /= this.scale; 
			positionInMap.x += this.myPosition.x; 
			positionInMap.y += this.myPosition.y; 
			return positionInMap; 
		} // convert from canvas position to map position 
		onHover() {
			if (this.isClickingMe(LMBStatus.position) && this.displayType === 'detailed') {
				var positionInMap = this.cvtFromCvsToMap(LMBStatus.position); 
				positionInMap = {x:positionInMap.x-this.myPosition.x, y:positionInMap.y-this.myPosition.y}; 
				if (myStatus.weapons[myStatus.selectedWeaponIndex] === 'torpedolauncher') {
					var torpModNumber = -1; 
			for (let i = 0; i < Ship.list[this.myShipName].components[myStatus.selectedTorpedoLauncherComponentId].modules.length; i++) {
				if (Ship.list[this.myShipName].components[myStatus.selectedTorpedoLauncherComponentId].modules[i].type === 'torpedolauncher') {
					torpModNumber = i; 
				}
			}
					if (Ship.list[myStatus.name].components[myStatus.selectedTorpedoLauncherComponentId].modules[torpModNumber].reloadCountDown > 0) {
						myStatus.findNextTorpedoLauncher(); 
					}
					var torpCpntPos = {x:Ship.list[myStatus.name].components[myStatus.selectedTorpedoLauncherComponentId].position.x, y:Ship.list[myStatus.name].components[myStatus.selectedTorpedoLauncherComponentId].position.y}; 
					torpCpntPos = {x:torpCpntPos.x*Math.cos(Ship.list[myStatus.name].bearing)-torpCpntPos.y*Math.sin(Ship.list[myStatus.name].bearing), y:torpCpntPos.x*Math.sin(Ship.list[myStatus.name].bearing)+torpCpntPos.y*Math.cos(Ship.list[myStatus.name].bearing)}; 
					positionInMap = {x:positionInMap.x-torpCpntPos.x, y:positionInMap.y-torpCpntPos.y}; 
				}
				myStatus.aimDirection = mod(Math.atan2(positionInMap.y, positionInMap.x) - Ship.list[myStatus.name].bearing, 2*Math.PI); 
				/*
				if (myStatus.weapons[myStatus.selectedWeaponIndex] === 'torpedolauncher') {
					myStatus.torpedoTubeDirection = (Math.atan2(positionInMap.y, positionInMap.x) + 2*Math.PI)%(2*Math.PI); 
					var lastMouseDownPositionInMap = this.cvtFromCvsToMap(LMBStatus.lastMouseDownPosition); 
					lastMouseDownPositionInMap = {x:lastMouseDownPositionInMap.x-this.myPosition.x, y:lastMouseDownPositionInMap.y-this.myPosition.y}; 
					if (LMBStatus.pressed) {
						myStatus.torpedoTubeSpread = Math.abs(Math.atan2(positionInMap.y*lastMouseDownPositionInMap.x - positionInMap.x*lastMouseDownPositionInMap.y, positionInMap.x*lastMouseDownPositionInMap.x + positionInMap.y*lastMouseDownPositionInMap.y)); 
						if (LMBStatus.shift) {
							myStatus.torpedoTubeSpread = Math.ceil((myStatus.torpedoTubeSpread + 0.0001)/0.075)*0.075; 
						}
					}
				}
				Setting up torpedo spread by dragging */ 
			}
		}
		onClick(position, event) {
			if (this.isClickingMe(position, event) && this.show && this.displayType === 'detailed') {
				var positionInMap = this.cvtFromCvsToMap(position); 
				
				
				if (myStatus.weapons[myStatus.selectedWeaponIndex] === 'gun') {
					if (event.shiftKey) {
						var closestShipName = undefined; 
						var minDistanceSquared = mapInfo.size.x*mapInfo.size.x + mapInfo.size.y*mapInfo.size.y; 
						for (let shipName in Ship.list) {
							var currentDistanceSquared = (Ship.list[shipName].position.x - positionInMap.x)*(Ship.list[shipName].position.x - positionInMap.x) + (Ship.list[shipName].position.y - positionInMap.y)*(Ship.list[shipName].position.y - positionInMap.y); 
							if ((closestShipName === undefined || currentDistanceSquared < minDistanceSquared) && shipName != this.myShipName) {
								minDistanceSquared = currentDistanceSquared; 
								closestShipName = shipName; 
							}
						}
						socket.emit('selectEnemy', closestShipName); 
					}
					else {
						socket.emit('fireSelectedWeapon', {
							type:'gun', 
							info:positionInMap
						}); 
					}
				}
				else if (myStatus.weapons[myStatus.selectedWeaponIndex] === 'minelayer') {
					socket.emit('fireSelectedWeapon', {type:'minelayer'}); 
				}
				else if (myStatus.weapons[myStatus.selectedWeaponIndex] === 'torpedolauncher') {
					socket.emit('fireSelectedWeapon', {
						type:'torpedolauncher', 
						info: {
							relativeDirection: myStatus.aimDirection, 
							spread: myStatus.torpedoSpreadOptions[myStatus.torpedoSpread], 
							componentId: myStatus.selectedTorpedoLauncherComponentId
						}
					}); 
					myStatus.findNextTorpedoLauncher(); 
				}
			}
		}
	}; 
	
	class StatusBarItem extends CanvasComponent {
		constructor(position, size, color, shipName) {
			super(position, size, color); 
			CanvasComponent.list.splice(-1, 1); 
			this.shipName = shipName; 
		}
		update(shipName) {
			this.shipName = shipName; 
		}
	}; 
	
	class SpeedBar extends StatusBarItem {
		constructor(position, status) {
			super(position, {width:100, height:100}, 'white', status.name); 
			this.rudderLockDic = {'left': -this.size.width/2, 'straight': 0, 'right': this.size.width/2}; 
			this.speedLockDic = {'full': 4*this.size.height/5, 'half': 2*this.size.height/5, 'stop': 0, 'reverse': -this.size.height/5}; 
			this.status = status; 
		}
		setTransform() {
			ctx.setTransform(1, 0, 0, -1, this.position.x + this.size.width/2, this.position.y + 4*this.size.height/5); 
		} // set you up for drawing
		draw() {
			super.draw(); 
			ctx.strokeStyle="black";
			ctx.lineWidth=5;
			ctx.beginPath();
			ctx.moveTo(this.rudderLockDic['left'], 0); 
			ctx.lineTo(this.rudderLockDic['right'], 0);
			ctx.stroke();
			ctx.beginPath();
			ctx.moveTo(0, this.speedLockDic['full']); 
			ctx.lineTo(0, this.speedLockDic['reverse']);
			ctx.stroke();
			ctx.fillStyle = 'red';
			ctx.fillRect(this.rudderLockDic[this.status.rudderLock]-5, this.speedLockDic[this.status.speedLevels[this.status.speedLevelIndex]]-5, 10, 10); 
			ctx.fillStyle = 'blue';
			ctx.fillRect(this.rudderLockDic['left']*this.status.currentRudderFrac-5, this.speedLockDic['full']*this.status.currentSpeedFrac-5, 10, 10); 
		}
	}; // This is a private bar 
	
	class TextBar extends StatusBarItem {
		constructor(position, shipName, text) {
			super(position, {width: 100, height: 20}, 'grey', shipName); 
			this.text = text; 
		}
		draw() {
			super.draw(); 
			ctx.fillStyle = 'black'; 
			ctx.fillText(this.text, 0, this.size.height - 5); 
		}
	}; // This is a public bar 
	
	class SelectedWeaponBar extends TextBar {
		constructor(position, status) {
			super(position, undefined, undefined); 
			this.status = status; 
		}
		draw() {
			this.text = this.status.weapons[this.status.selectedWeaponIndex]; 
			super.draw(); 
		}
	}; // This is a private bar 
	
	class NameBar extends TextBar {
		constructor(position, shipName) {
			super(position, shipName, shipName); 
		}
		update(shipName) {
			super.update(shipName); 
			this.text = shipName; 
		}
	}; // This is a public bar 
	
	class ShipGraph extends StatusBarItem {
		constructor(position, shipName) {
			super(position, {width: 100, height: 100}, 'grey', shipName); 
			this.scale = 0.2; 
		}
		setTransform() {
			ctx.setTransform(this.scale, 0, 0, -this.scale, this.position.x + this.size.width/2, this.position.y + this.size.height/2); 
			ctx.transform(1, 0, 0, 1, -Ship.list[this.shipName].position.x, -Ship.list[this.shipName].position.y); 
		} 
		draw() {
			super.draw(); 
			Ship.list[this.shipName].draw(this.scale, 'detailed', undefined, undefined, undefined, undefined, false, true, true); 
		}
	}; // This is a public bar 
	
	class ModuleBar extends StatusBarItem {
		constructor(position, shipName, componentId, id) {
			super(position, {width:25, height:25}, 'black', shipName); 
			this.componentId = componentId; 
			this.id = id; 
			this.scale = 1/4; 
		}
		setTransform() {
			ctx.setTransform(this.scale, 0, 0, -this.scale, this.position.x + this.size.width/2, this.position.y + this.size.height/2);
		}
		draw() {
			if ('reloadCountDown' in Ship.list[this.shipName].components[this.componentId].modules[this.id]) {
			if (Ship.list[this.shipName].components[this.componentId].modules[this.id].reloadCountDown === 0) {
				this.color = 'green'; 
			}
			else {
				var colorNumber = (Ship.list[this.shipName].components[this.componentId].modules[this.id].reloadCountDown/Ship.list[this.shipName].components[this.componentId].modules[this.id].stats.reload); 
				this.color = 'rgba(255,255,255,' + colorNumber + ')'; 
			}
			}
			else {
				this.color = 'green'; 
			}
			super.draw(); 
			drawModule.showAll[Ship.list[this.shipName].components[this.componentId].modules[this.id].type](Ship.list[this.shipName].components[this.componentId].modules[this.id].multiplicity); 
			if (Ship.list[this.shipName].components[this.componentId].modules[this.id].reloadCountDown > 0) {
				ctx.setTransform(1, 0, 0, 1, this.position.x, this.position.y + this.size.height); 
				ctx.fillStyle = 'black'; 
				ctx.fillText(Math.ceil(Ship.list[this.shipName].components[this.componentId].modules[this.id].reloadCountDown), 0, 0); 
			}
		}
	}; // This is a public bar 
	
	class ComponentBar extends StatusBarItem {
		constructor(position, shipName, id) {
			super(position, {width: 100, height: 25}, 'grey', shipName); 
			this.id = id; 
			this.scale = 1/5; 
			this.modules = []; 
			var currentXwidth = this.size.height; 
			for (let i = 0; i < Ship.list[shipName].components[id].modules.length; i++) {
				this.modules.push(new ModuleBar({x:this.position.x + currentXwidth, y:this.position.y}, shipName, id, i)); 
				currentXwidth += this.modules[this.modules.length-1].size.height; 
			}
		}
		draw() {
			super.draw(); 
			ctx.transform(0, -this.scale, this.scale, 0, this.size.height/2, this.size.height/2); 
			ctx.fillStyle = 'rgb(' + Math.floor(255 - Ship.list[this.shipName].components[this.id].HP*255/5) + ', 0, 0)'; 
			if (Ship.list[this.shipName].components[this.id].shape.type === 'polygon') {
				ctx.beginPath();
				ctx.moveTo(Ship.list[this.shipName].components[this.id].shape.vertices[0].x, Ship.list[this.shipName].components[this.id].shape.vertices[0].y); 
				for (let j = 1; j < Ship.list[this.shipName].components[this.id].shape.vertices.length; j++) {
					ctx.lineTo(Ship.list[this.shipName].components[this.id].shape.vertices[j].x, Ship.list[this.shipName].components[this.id].shape.vertices[j].y);
				}
				ctx.closePath(); 
				ctx.fill(); 
			} 
			for (let i = 0; i < this.modules.length; i++) {
				this.modules[i].draw(); 
			}
		}
	}; // This is a public bar 
	
	class ComponentDetailsBar extends StatusBarItem {
		constructor(position, shipName) {
			super(position, {width:100, height:200}, 'grey', undefined); 
			this.components = []; 
		}
		update(shipName) {
			if (shipName === this.shipName) {} 
			else if (shipName === undefined) {this.components = []; }
			else {
				super.update(shipName); 
				this.components = []; 
				var currentYHeight = 0; 
				for (let i = 0; i < Ship.list[shipName].components.length; i++) {
					this.components.push(new ComponentBar({x:this.position.x, y:this.position.y + currentYHeight}, shipName, i)); 
					currentYHeight += this.components[this.components.length-1].size.height + 5; 
				}
			} 
		}
		draw() {
			super.draw(); 
			for (let i = 0; i < this.components.length; i++) {
				this.components[i].draw(); 
			}
		}
	}; 
	
	class StatusBar extends CanvasComponent {
		constructor(position) {
			super(position, {width:100, height:500}, 'grey'); 
			this.bars = {}; 
		}
	}; 
	
	class PrivateStatusBar extends StatusBar {
		constructor(position, status) {
			super(position); 
			this.status = status; 
			this.bars['SelectedWeaponBar'] = new SelectedWeaponBar({x:this.position.x, y:this.position.y}, this.status); 
			this.bars['speedBar'] = new SpeedBar({x:this.position.x, y:this.position.y+350}, this.status); 
		}
		draw() {
			super.draw(); 
			for (let bar in this.bars) {
				this.bars[bar].draw(); 
			}
		}
	}; 
	
	class PublicStatusBar extends StatusBar {
		constructor(position, shipName) {
			super(position); 
			this.shipName = shipName; 
			this.bars['nameBar'] = new NameBar({x:this.position.x, y:this.position.y}, shipName); 
			this.bars['shipGraph'] = new ShipGraph({x:this.position.x, y:this.position.y + 20}, shipName); 
			this.bars['ComponentDetailsBar'] = new ComponentDetailsBar({x:this.position.x, y:this.position.y + 120}, shipName); 
		}
		update(shipName) {
			this.shipName = shipName; 
			for (let bar in this.bars) {
				this.bars[bar].update(shipName); 
			}
		}
		draw() {
			super.draw(); 
			if (this.shipName !== undefined) {
				for (let bar in this.bars) {
					this.bars[bar].draw(); 
				}
			}
		}
	}; 
	
	// Socket package handling 
	// Signup response 
	socket.on('signUpResponse', function(data){
		if (data.success){
			signUpDiv.style.display = 'none'; 
			mapInfo = data.mapInfo; 
			wholeCanvas = new CanvasComponent({x:0,y:0}, {width:1000, height:500}, 'white'); 
			myStatus = new Status(); 
			myStatus.name = data.myShip.name; 
			mainMap = new MapComponent({x:200, y:0}, {width:500, height:500}, data.myShip.name, 1/10, '#AED6F1', 'detailed', 'centered', 10, true, true); 
			miniMap = new MapComponent({x:200, y:0}, undefined, data.myShip.name, 1/100, 'black', 'dummy', 'whole', 0, false, false); 
			scope = new MapComponent({x:800, y:0}, {width:200, height:200}, undefined, 1/5, 'white', 'detailed', 'centered', 10, false, false)
			privateStatusBar = new PrivateStatusBar({x:0, y:0}, myStatus); 
			myStatusBar = new PublicStatusBar({x:100, y:0}, data.myShip.name); 
			enemyStatusBar = new PublicStatusBar({x:700, y:0}, undefined); 
			gameDiv.style.display = 'inline-block'; 
		} 
		else {alert(data.msg); }
	}); 
	
	// Update frame 
	socket.on('updateFrame', function(data){
		// data is composed of: 
		// a dictionary detectedShipList, with entries name:{position: {x, y}, bearing, components} 
		// a dictionary myShip = {currentSpeedFrac, currentRudderFrac} 
		// a dictionary enemyShip = {name} 
		
		// update 
		Mine.update(data.detectedMineList); 
		Torpedo.update(data.detectedTorpedoList); 
		Shell.update(data.detectedShellList); 
		Ship.update(data.detectedShipInfoList); 
		myStatus.update(data.myShip); 
		myStatusBar.update(myStatus.name); 
		enemyStatusBar.update(data.enemyShip.name); 
		scope.myShipName = data.enemyShip.name; 
		scope.show = (data.enemyShip.name !== undefined) && (myStatus.weapons[myStatus.selectedWeaponIndex] === 'gun'); 
		
		// draw 
		for(let i=0; i < CanvasComponent.list.length; i++) {
			CanvasComponent.list[i].draw(); 
		}
		ctx.setTransform(1, 0, 0, 1, 0, 0); 
	}); 
	
	// Control handling 
	document.onkeydown = function(event){
		if (event.keyCode === 65) {// On pressing 'a' 
			myStatus.rudderLock = 'left'; 
			socket.emit('rudderShift', 'left'); 
		} 
		else if (event.keyCode === 68) {
			myStatus.rudderLock = 'right'; 
			socket.emit('rudderShift', 'right'); 
		} 
		else if (event.keyCode === 81) {
			if (myStatus.rudderLock === 'right') {
				myStatus.rudderLock = 'straight'; 
				socket.emit('rudderShift', 'straight'); 
			}
			else {
				myStatus.rudderLock = 'left'; 
				socket.emit('rudderShift', 'left'); 
			}
		} 
		else if (event.keyCode === 69) {
			if (myStatus.rudderLock === 'left') {
				myStatus.rudderLock = 'straight'; 
				socket.emit('rudderShift', 'straight'); 
			}
			else {
				myStatus.rudderLock = 'right'; 
				socket.emit('rudderShift', 'right'); 
			}
		} 
		else if (event.keyCode === 87) {
			myStatus.speedLevelIndex = Math.min(myStatus.speedLevelIndex + 1, 3)
			socket.emit('speedChange', myStatus.speedLevels[myStatus.speedLevelIndex]); 
		} 
		else if (event.keyCode === 83) {
			myStatus.speedLevelIndex = Math.max(myStatus.speedLevelIndex - 1, 0)
			socket.emit('speedChange', myStatus.speedLevels[myStatus.speedLevelIndex]); 
		} 
		else if (event.keyCode > 48 && event.keyCode < 48 + myStatus.weapons.length) {
			myStatus.selectedWeaponIndex = event.keyCode - 48; 
			if (myStatus.weapons[event.keyCode - 48] === 'torpedolauncher') {
				myStatus.findNextTorpedoLauncher(); 
			}
		} 
		else if (event.keyCode === 32) {
			if (myStatus.weapons[myStatus.selectedWeaponIndex] === 'torpedolauncher') {
				if (myStatus.torpedoSpread === 'narrow') {
					myStatus.torpedoSpread = 'wide'; 
				}
				else {
					myStatus.torpedoSpread = 'narrow'; 
				}
			}
		} 
		else if (event.keyCode === 16) {
			LMBStatus.shift = true; 
			if (myStatus.weapons[myStatus.selectedWeaponIndex] === 'torpedolauncher' && (myStatus.name in Ship.list)) {
				myStatus.findNextTorpedoLauncher(); 
			}
		} 
	}; 
	
	document.onkeyup = function(event){
		if (event.keyCode === 65) {
			myStatus.rudderLock = 'straight'; 
			socket.emit('rudderShift', 'straight'); 
		} 
		else if (event.keyCode === 68) {
			myStatus.rudderLock = 'straight'; 
			socket.emit('rudderShift', 'straight'); 
		} 
		else if (event.keyCode === 16) {
			LMBStatus.shift = false; 
		} 
	}; 
	
	document.onmousedown = function(event){
		LMBStatus.update(event.pageX - gameDiv.getBoundingClientRect().x, event.pageY - gameDiv.getBoundingClientRect().y, true); 
		for (let i = 0; i < CanvasComponent.list.length; i++) {
			CanvasComponent.list[i].onClick(LMBStatus.position, event); 
		}
	}; 
	
	document.onmouseup = function(event){
		LMBStatus.update(event.pageX - gameDiv.getBoundingClientRect().x, event.pageY - gameDiv.getBoundingClientRect().y, false); 
	}; 
	
	document.onmousemove = function(event){
		LMBStatus.update(event.pageX - gameDiv.getBoundingClientRect().x, event.pageY - gameDiv.getBoundingClientRect().y, LMBStatus.pressed); 
	}; 
</script>