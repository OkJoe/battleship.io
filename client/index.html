<div id="signUpDiv">
	name: <input id="signUpName" type="text"></input>
	<button id="signUpButton">Sign Up</button>
</div>

<div id="gameDiv" style="display:none;">
	<canvas id="ctx" width="1000" height="500" style="border:1px solid #000000;"></canvas>
</div>

<script src="client/js/socket.io-1.4.5.js"></script>

<script>
	var socket = io(); 
	function mod(a,b) {
		return (a%b+b)%b; 
	}; 
	
	//Sign up 
	var signUpDiv = document.getElementById("signUpDiv"); 
	var signUpName = document.getElementById("signUpName"); 
	var signUpButton = document.getElementById("signUpButton"); 
	var gameDiv = document.getElementById("gameDiv"); 
	
	signUpButton.onclick = function(){
		socket.emit('signUp', {name:signUpName.value}); 
	}; 
	
	//Canvas setting 
	var wholeCanvas; 
	var mainMap; 
	var miniMap; 
	var mapInfo; 
	var privateStatusBar; 
	var myStatusBar; 
	var enemyStatusBar; 
	var LMBStatus = {
		position: {x: 0, y: 0}, 
		lastMouseDownPosition: {x: 0, y: 0}, 
		pressed: false, 
		shift: false, 
		update: function(x, y, pressed) {
			this.position.x = x; 
			this.position.y = y; 
			if (pressed && !this.pressed) {
				this.lastMouseDownPosition = {x, y}; 
			}
			this.pressed = pressed; 
		}
	}; 
	
	var cvs = document.getElementById("ctx"); 
	var ctx = cvs.getContext("2d"); 
	ctx.font = '15px Arial'; 
	
	//Game objects 
	
	class Status {
		constructor() {
			this.speedLevels = ['reverse', 'stop', 'half', 'full']
			this.speedLevelIndex = 1; 
			this.rudderLock = 'straight'; // Can also take value 'left' or 'right', which evaluate to boolean true 
			this.currentSpeedFrac = 0; 
			this.currentRudderFrac = 0; 
			this.name = undefined; 
			this.weapons = ['???', 'minelayer', 'torpedolauncher']; 
			this.selectedWeaponIndex = 1; 
			this.torpedoTubeDirection = 0; 
			this.torpedoTubeSpread = 0.2; 
		}
		update(currentSpeedFrac, currentRudderFrac) {
			this.currentSpeedFrac = currentSpeedFrac; 
			this.currentRudderFrac = currentRudderFrac; 
		} 
		getInfo() {
			if (this.weapons[this.selectedWeaponIndex] === 'minelayer') {
				return undefined; 
			}
			else if (this.weapons[this.selectedWeaponIndex] === 'torpedolauncher') {
				return {
					relativeDirection: mod((this.torpedoTubeDirection - Ship.list[this.name].bearing), 2 * Math.PI), 
					spread: this.torpedoTubeSpread
				}
			}
		}
	}; 
	var myStatus = new Status(); 
	
	class Entity {
		constructor(position, bearing) {
			this.position = position; 
			this.bearing = bearing; 
		}
		isInMapScope(scale, displayFrameSize, mapCenterPosition) {
			if (Math.abs(this.position.x-mapCenterPosition.x) <= displayFrameSize.width/scale/2 && Math.abs(this.position.y-mapCenterPosition.y) <= displayFrameSize.height/scale/2) {
				return true; 
			}
			else {return false; }
		}
		draw(scale) {}
	}; 
	
	class Weapon extends Entity {
		constructor(position, activated, bearing) {
			super(position, bearing); 
			this.activated = activated; 
		} 
		drawShape(scale, color) {}
		draw(scale, displayFrameSize, myPosition) {
			if (this.isInMapScope(scale, displayFrameSize, myPosition)) {
				var color; 
				if (this.activated) {
					color = 'red'; 
				}
				else {
					color = 'white'; 
				}
				this.drawShape(scale, color); 
			}
		} 
		static update(newList) {
			for(let id in this.list) {
				if (!(id in newList)){
					delete this.list[id]; 
				}
			}
			for(let id in newList) {
				if (!(id in this.list)) {
					this.list[id] = new this(newList[id].position, newList[id].activated, newList[id].direction); 
				}
				else {
					this.list[id].position = newList[id].position; 
					this.list[id].activated = newList[id].activated; 
					this.list[id].bearing = newList[id].direction; 
				}
			}
		} 
	} 
	
	class Mine extends Weapon {
		constructor(position, activated) {
			super(position, activated, undefined); 
		} 
		drawShape(scale, color) {
			ctx.fillStyle = color; 
			ctx.fillRect(this.position.x-2/scale, this.position.y-2/scale, 4/scale, 4/scale); 
		} 
	} 
	Mine.list = {}; 
	
	class Torpedo extends Weapon {
		constructor(position, activated, bearing) {
			super(position, activated, bearing); 
		} 
		drawShape(scale, color) {
			ctx.lineWidth=3/scale;
			ctx.strokeStyle = color;
			ctx.beginPath();
			ctx.moveTo(this.position.x, this.position.y); 
			ctx.lineTo(this.position.x - Math.cos(this.bearing)*10/scale, this.position.y - Math.sin(this.bearing)*10/scale);
			ctx.stroke(); 
		} 
	} 
	Torpedo.list = {}; 
	
	class Ship extends Entity {
		constructor(name, position, bearing, components) {
			super(position, bearing); 
			this.components = components; 
			this.name = name; // Maybe delete this 
		}
		update(position, bearing, components) {
			this.position = position; 
			this.bearing = bearing; 
			this.components = components; 
		}
		draw(scale, displayType, scopeType, displayFrameSize, myPosition, drawingMe, showName, bearingAhead, showDmg) {
			var drawShip = true; 
			if (scopeType === 'centered') {
				drawShip = this.isInMapScope(scale, displayFrameSize, myPosition); 
			} 
			if (drawShip) {
				if (displayType === 'detailed') {
					if (showName) {
						ctx.transform(1/scale, 0, 0, -1/scale, this.position.x, this.position.y); 
						ctx.fillStyle = 'black'; 
						ctx.fillText(this.name, -5, -15); 
						ctx.transform(scale, 0, 0, -scale, 0, 0); 
					}
					else {ctx.transform(1, 0, 0, 1, this.position.x, this.position.y); }
					
					/*
					if (bearingRelMyShip) {
						var relVectorLength = Math.sqrt((this.position.x - Ship.list[myStatus.name].position.x)*(this.position.x - Ship.list[myStatus.name].position.x) + (this.position.y - Ship.list[myStatus.name].position.y)*(this.position.y - Ship.list[myStatus.name].position.y)); 
						if (relVectorLength === 0) {
							ctx.transform(0, 1, -1, 0, 0, 0);
						}
						else {
							var relVectorCos = (this.position.x - Ship.list[myStatus.name].position.x)/relVectorLength; 
							var relVectorSin = (this.position.y - Ship.list[myStatus.name].position.y)/relVectorLength; 
							ctx.transform(Math.cos(this.bearing), Math.sin(this.bearing), -Math.sin(this.bearing), Math.cos(this.bearing), 0, 0); 
							ctx.transform(relVectorCos, -relVectorSin, relVectorSin, relVectorCos, 0, 0); 
							ctx.transform(0, 1, -1, 0, 0, 0); 
						}
					}*/
					
					if (bearingAhead) {
						ctx.transform(0, 1, -1, 0, 0, 0); 
					}
					
					else {ctx.transform(Math.cos(this.bearing), Math.sin(this.bearing), -Math.sin(this.bearing), Math.cos(this.bearing), 0, 0); } 
					for (let i = 0; i < this.components.length; i++) {
						if (showDmg) {ctx.fillStyle = 'rgb(' + Math.floor(255 - this.components[i].HP*255/5) + ', 0, 0)'; }
						else {ctx.fillStyle = 'black'; } 
						if (this.components[i].shape.type === 'polygon') {
							ctx.transform(1, 0, 0, 1, this.components[i].position.x, this.components[i].position.y); 
							ctx.beginPath();
							ctx.moveTo(this.components[i].shape.vertices[0].x, this.components[i].shape.vertices[0].y); 
							for (let j = 1; j < this.components[i].shape.vertices.length; j++) {
								ctx.lineTo(this.components[i].shape.vertices[j].x, this.components[i].shape.vertices[j].y);
							}
							ctx.closePath(); 
							ctx.fill(); 
							ctx.transform(1, 0, 0, 1, -this.components[i].position.x, -this.components[i].position.y); 
						}
					}
				}
				else if (displayType === 'dummy') {
					if (drawingMe) {ctx.fillStyle = 'green'; }
					else {ctx.fillStyle = 'white'; }
					ctx.fillRect(this.position.x-2/scale, this.position.y-2/scale, 4/scale, 4/scale); 
				}
			}
		}
		static update(newShipList) {
			for(let shipName in Ship.list) {
				if (!(shipName in newShipList)){
					delete Ship.list[shipName]; 
				}
			}
			for(let shipName in newShipList) {
				if (shipName in Ship.list) {
					Ship.list[shipName].update(newShipList[shipName].position, newShipList[shipName].bearing, newShipList[shipName].components); 
				}
				else {
					var ship = new Ship(shipName, newShipList[shipName].position, newShipList[shipName].bearing, newShipList[shipName].components); 
					Ship.list[shipName] = ship; 
				}
			}
		}
	}; 
	Ship.list = {}; 
	
	//Canvas objects 
	
	class CanvasComponent {
		constructor(position, size, color) {
			CanvasComponent.list.push(this); 
			this.position = position; // position = {x, y} 
			this.size = size; // size = {width, height} 
			this.color = color; 
		}
		setTransform() {
			ctx.setTransform(1, 0, 0, 1, this.position.x, this.position.y); 
		} // set you up for drawing
		draw() { 
			ctx.fillStyle = this.color;
			ctx.setTransform(1, 0, 0, 1, 0, 0); 
			ctx.fillRect(this.position.x, this.position.y, this.size.width, this.size.height); // clear the component 
			this.setTransform(); 
		}
		isClickingMe(position) {
			if (position.x <= this.position.x) {
				return false; 
			}
			else if (position.x >= this.position.x + this.size.width) {
				return false; 
			}
			else if (position.y <= this.position.y) {
				return false; 
			}
			else if (position.y >= this.position.y + this.size.height) {
				return false; 
			}
			return true; 
		}
		onClick(position, event) {
			if (this.isClickingMe(position, event)) {
				// Do something 
			}
		}
	}; 
	CanvasComponent.list = []; // This is really a list, made to draw in the right order 
	
	class MapComponent extends CanvasComponent {
		constructor(position, size, myShip, scale, color, displayType, scopeType, grid, showName, drawWeapon) {
			super(position, size, color); 
			if (scopeType === 'whole') {
				this.size = {width:mapInfo.size.x*scale, height:mapInfo.size.y*scale}; 
			}
			this.scale = scale; 
			this.myShipName = myShip.name; 
			this.myPosition = {x:mapInfo.size.x/2, y:mapInfo.size.y/2}; 
			this.displayType = displayType; 
			this.scopeType = scopeType; 
			this.grid = grid; 
			this.showName = showName; 
			this.drawWeapon = drawWeapon; 
		}
		setTransform() {
			ctx.setTransform(this.scale, 0, 0, -this.scale, this.position.x + this.size.width/2, this.position.y + this.size.height/2);
			ctx.transform(1, 0, 0, 1, -this.myPosition.x, -this.myPosition.y);
		}
		drawGrid() {
			if (this.grid > 1) {
				this.setTransform(); 
				for(let i = Math.max(Math.ceil((this.myPosition.x - this.size.width/this.scale/2)/(mapInfo.size.x/this.grid))*(mapInfo.size.x/this.grid), 0); i <= Math.min((this.myPosition.x + this.size.width/this.scale/2), mapInfo.size.x); i += (mapInfo.size.x/this.grid)) {
					ctx.lineWidth=2/this.scale;
					ctx.strokeStyle="grey";
					ctx.beginPath();
					ctx.moveTo(i, Math.max(this.myPosition.y - this.size.height/this.scale/2, 0)); 
					ctx.lineTo(i, Math.min(this.myPosition.y + this.size.height/this.scale/2, mapInfo.size.y));
					ctx.stroke();
				}
				for(let i = Math.max(Math.ceil((this.myPosition.y - this.size.height/this.scale/2)/(mapInfo.size.y/this.grid))*(mapInfo.size.y/this.grid), 0); i <= Math.min((this.myPosition.y + this.size.height/this.scale/2), mapInfo.size.y); i += (mapInfo.size.y/this.grid)) {
					ctx.lineWidth=2/this.scale;
					ctx.strokeStyle="grey";
					ctx.beginPath();
					ctx.moveTo(Math.max(this.myPosition.x - this.size.width/this.scale/2, 0), i); 
					ctx.lineTo(Math.min(this.myPosition.x + this.size.width/this.scale/2, mapInfo.size.x), i);
					ctx.stroke();
				}
			}
		}
		drawTorpedoTubeLines()	{
			this.setTransform(); 
			if (myStatus.weapons[myStatus.selectedWeaponIndex] === 'torpedolauncher' && this.displayType === 'detailed') {
				var range = 1000; 
				ctx.strokeStyle="white"; 
				ctx.beginPath();
				ctx.moveTo(this.myPosition.x, this.myPosition.y); 
				ctx.lineTo(this.myPosition.x + Math.cos(myStatus.torpedoTubeDirection)*range, this.myPosition.y + Math.sin(myStatus.torpedoTubeDirection)*range); 
				ctx.stroke();
				ctx.strokeStyle="green"; 
				ctx.beginPath();
				ctx.moveTo(this.myPosition.x, this.myPosition.y); 
				ctx.lineTo(this.myPosition.x + Math.cos(myStatus.torpedoTubeDirection + myStatus.torpedoTubeSpread)*range, this.myPosition.y + Math.sin(myStatus.torpedoTubeDirection + myStatus.torpedoTubeSpread)*range); 
				ctx.stroke();
				ctx.beginPath();
				ctx.moveTo(this.myPosition.x, this.myPosition.y); 
				ctx.lineTo(this.myPosition.x + Math.cos(myStatus.torpedoTubeDirection - myStatus.torpedoTubeSpread)*range, this.myPosition.y + Math.sin(myStatus.torpedoTubeDirection - myStatus.torpedoTubeSpread)*range); 
				ctx.stroke();
			}
		}
		draw() {
			super.draw(); 
			if (this.scopeType === 'centered') {this.myPosition = Ship.list[this.myShipName].position; } 
			
			//draw grid 
			this.drawGrid(); 
			
			//draw torpedo tube lines 
			this.onHover(); 
			this.drawTorpedoTubeLines(); 
			
			//draw ships 
			for(let name in Ship.list) {
				this.setTransform(); 
				Ship.list[name].draw(this.scale, this.displayType, this.scopeType, this.size, this.myPosition, (name === this.myShipName), this.showName, false); 
			}
			
			//draw weapons 
			if (this.drawWeapon) {
				for(let id in Mine.list) {
					this.setTransform(); 
					Mine.list[id].draw(this.scale, this.size, this.myPosition); 
				}
				for(let id in Torpedo.list) {
					this.setTransform(); 
					Torpedo.list[id].draw(this.scale, this.size, this.myPosition); 
				}
			}
		}
		cvtFromCvsToMap(position) {
			var positionInMap = {x:position.x, y:position.y}; 
			positionInMap.x -= (this.position.x + this.size.width/2); 
			positionInMap.y = this.position.y - positionInMap.y + this.size.height/2; 
			positionInMap.x /= this.scale; 
			positionInMap.y /= this.scale; 
			positionInMap.x += this.myPosition.x; 
			positionInMap.y += this.myPosition.y; 
			return positionInMap; 
		} // convert from canvas position to map position 
		onHover() {
			if (this.isClickingMe(LMBStatus.position)) {
				if (myStatus.weapons[myStatus.selectedWeaponIndex] === 'torpedolauncher') {
					var positionInMap = this.cvtFromCvsToMap(LMBStatus.position); 
					positionInMap = {x:positionInMap.x-this.myPosition.x, y:positionInMap.y-this.myPosition.y}; 
					myStatus.torpedoTubeDirection = (Math.atan2(positionInMap.y, positionInMap.x) + 2*Math.PI)%(2*Math.PI); 
					var lastMouseDownPositionInMap = this.cvtFromCvsToMap(LMBStatus.lastMouseDownPosition); 
					lastMouseDownPositionInMap = {x:lastMouseDownPositionInMap.x-this.myPosition.x, y:lastMouseDownPositionInMap.y-this.myPosition.y}; 
					if (LMBStatus.pressed) {
						myStatus.torpedoTubeSpread = Math.abs(Math.atan2(positionInMap.y*lastMouseDownPositionInMap.x - positionInMap.x*lastMouseDownPositionInMap.y, positionInMap.x*lastMouseDownPositionInMap.x + positionInMap.y*lastMouseDownPositionInMap.y)); 
						if (LMBStatus.shift) {
							myStatus.torpedoTubeSpread = Math.ceil((myStatus.torpedoTubeSpread + 0.0001)/0.075)*0.075; 
						}
					}
				}
			}
		}
		onClick(position, event) {
			if (this.isClickingMe(position, event)) {
				var positionInMap = this.cvtFromCvsToMap(position); 
				
				if (event.altKey) {
					var closestShipName = undefined; 
					var minDistanceSquared = mapInfo.size.x*mapInfo.size.x + mapInfo.size.y*mapInfo.size.y; 
					for (let shipName in Ship.list) {
						var currentDistanceSquared = (Ship.list[shipName].position.x - positionInMap.x)*(Ship.list[shipName].position.x - positionInMap.x) + (Ship.list[shipName].position.y - positionInMap.y)*(Ship.list[shipName].position.y - positionInMap.y); 
						if ((closestShipName === undefined || currentDistanceSquared < minDistanceSquared) && shipName != this.myShipName) {
							minDistanceSquared = currentDistanceSquared; 
							closestShipName = shipName; 
						}
					}
					socket.emit('selectEnemy', closestShipName); 
				}
			}
		}
	}; 
	
	class StatusBarItem extends CanvasComponent {
		constructor(position, size, color, shipName) {
			super(position, size, color); 
			CanvasComponent.list.splice(-1, 1); 
			this.shipName = shipName; 
		}
		update(shipName) {
			this.shipName = shipName; 
		}
	}; 
	
	class SpeedBar extends StatusBarItem {
		constructor(position, status) {
			super(position, {width:100, height:100}, 'white', status.name); 
			this.rudderLockDic = {'left': -this.size.width/2, 'straight': 0, 'right': this.size.width/2}; 
			this.speedLockDic = {'full': 4*this.size.height/5, 'half': 2*this.size.height/5, 'stop': 0, 'reverse': -this.size.height/5}; 
			this.status = status; 
		}
		setTransform() {
			ctx.setTransform(1, 0, 0, -1, this.position.x + this.size.width/2, this.position.y + 4*this.size.height/5); 
		} // set you up for drawing
		draw() {
			super.draw(); 
			ctx.strokeStyle="black";
			ctx.lineWidth=5;
			ctx.beginPath();
			ctx.moveTo(this.rudderLockDic['left'], 0); 
			ctx.lineTo(this.rudderLockDic['right'], 0);
			ctx.stroke();
			ctx.beginPath();
			ctx.moveTo(0, this.speedLockDic['full']); 
			ctx.lineTo(0, this.speedLockDic['reverse']);
			ctx.stroke();
			ctx.fillStyle = 'red';
			ctx.fillRect(this.rudderLockDic[this.status.rudderLock]-5, this.speedLockDic[this.status.speedLevels[this.status.speedLevelIndex]]-5, 10, 10); 
			ctx.fillStyle = 'blue';
			ctx.fillRect(this.rudderLockDic['left']*this.status.currentRudderFrac-5, this.speedLockDic['full']*this.status.currentSpeedFrac-5, 10, 10); 
		}
	}; // This is a private bar 
	
	class TextBar extends StatusBarItem {
		constructor(position, shipName, text) {
			super(position, {width: 100, height: 20}, 'grey', shipName); 
			this.text = text; 
		}
		draw() {
			super.draw(); 
			ctx.fillStyle = 'black'; 
			ctx.fillText(this.text, 0, this.size.height - 5); 
		}
	}; // This is a public bar 
	
	class SelectedWeaponBar extends TextBar {
		constructor(position, status) {
			super(position, undefined, undefined); 
			this.status = status; 
		}
		draw() {
			this.text = this.status.weapons[this.status.selectedWeaponIndex]; 
			super.draw(); 
		}
	}; // This is a private bar 
	
	class NameBar extends TextBar {
		constructor(position, shipName) {
			super(position, shipName, shipName); 
		}
		update(shipName) {
			super.update(shipName); 
			this.text = shipName; 
		}
	}; // This is a public bar 
	
	class ShipGraph extends StatusBarItem {
		constructor(position, shipName) {
			super(position, {width: 100, height: 100}, 'grey', shipName); 
			this.scale = 0.2; 
		}
		setTransform() {
			ctx.setTransform(this.scale, 0, 0, -this.scale, this.position.x + this.size.width/2, this.position.y + this.size.height/2); 
			ctx.transform(1, 0, 0, 1, -Ship.list[this.shipName].position.x, -Ship.list[this.shipName].position.y); 
		} 
		draw() {
			super.draw(); 
			Ship.list[this.shipName].draw(this.scale, 'detailed', undefined, undefined, undefined, undefined, false, true, true); 
		}
	}; // This is a public bar 
	
	class ModuleBar extends TextBar {
		constructor(position, shipName, componentId, id) {
			super(position, shipName, undefined); 
			this.componentId = componentId; 
			this.id = id; 
		}
		draw() {
			this.text = Ship.list[this.shipName].components[this.componentId].modules[this.id].type + ': ' + Math.ceil(Ship.list[this.shipName].components[this.componentId].modules[this.id].reloadCountDown); 
			super.draw(); 
		}
	}; // This is a public bar 
	
	class ComponentBar extends StatusBarItem {
		constructor(position, shipName, id) {
			super(position, {width: 100, height: 60}, 'grey', shipName); 
			this.id = id; 
			this.modules = [new TextBar(this.position, shipName, 'component')]; 
			var currentYHeight = this.modules[0].size.height; 
			for (let i = 0; i < Ship.list[shipName].components[id].modules.length; i++) {
				this.modules.push(new ModuleBar({x:this.position.x, y:this.position.y + currentYHeight}, shipName, id, i)); 
				currentYHeight += this.modules[this.modules.length-1].size.height; 
			}
		}
		draw() {
			super.draw(); 
			for (let i = 0; i < this.modules.length; i++) {
				this.modules[i].draw(); 
			}
		}
	}; // This is a public bar 
	
	class ComponentDetailsBar extends StatusBarItem {
		constructor(position, shipName) {
			super(position, {width:100, height:200}, 'grey', undefined); 
			this.components = []; 
		}
		update(shipName) {
			if (shipName === this.shipName) {} 
			else if (shipName === undefined) {this.components = []; }
			else {
				super.update(shipName); 
				this.components = []; 
				var currentYHeight = 0; 
				for (let i = 0; i < Ship.list[shipName].components.length; i++) {
					this.components.push(new ComponentBar({x:this.position.x, y:this.position.y + currentYHeight}, shipName, i)); 
					currentYHeight += this.components[this.components.length-1].size.height; 
				}
			} 
		}
		draw() {
			super.draw(); 
			for (let i = 0; i < this.components.length; i++) {
				this.components[i].draw(); 
			}
		}
	}; 
	
	class StatusBar extends CanvasComponent {
		constructor(position) {
			super(position, {width:100, height:500}, 'grey'); 
			this.bars = {}; 
		}
	}; 
	
	class PrivateStatusBar extends StatusBar {
		constructor(position, status) {
			super(position); 
			this.status = status; 
			this.bars['SelectedWeaponBar'] = new SelectedWeaponBar({x:this.position.x, y:this.position.y}, this.status); 
			this.bars['speedBar'] = new SpeedBar({x:this.position.x, y:this.position.y+350}, this.status); 
		}
		draw() {
			super.draw(); 
			for (let bar in this.bars) {
				this.bars[bar].draw(); 
			}
		}
	}; 
	
	class PublicStatusBar extends StatusBar {
		constructor(position, shipName) {
			super(position); 
			this.shipName = shipName; 
			this.bars['nameBar'] = new NameBar({x:this.position.x, y:this.position.y}, shipName); 
			this.bars['shipGraph'] = new ShipGraph({x:this.position.x, y:this.position.y + 20}, shipName); 
			this.bars['ComponentDetailsBar'] = new ComponentDetailsBar({x:this.position.x, y:this.position.y + 120}, shipName); 
		}
		update(shipName) {
			this.shipName = shipName; 
			for (let bar in this.bars) {
				this.bars[bar].update(shipName); 
			}
		}
		draw() {
			super.draw(); 
			if (this.shipName !== undefined) {
				for (let bar in this.bars) {
					this.bars[bar].draw(); 
				}
			}
		}
	}; 
	
	// Socket package handling 
	// Signup response 
	socket.on('signUpResponse', function(data){
		if (data.success){
			signUpDiv.style.display = 'none'; 
			mapInfo = data.mapInfo; 
			wholeCanvas = new CanvasComponent({x:0,y:0}, {width:1000, height:500}, 'white'); 
			myStatus = new Status(); 
			myStatus.name = data.myShip.name; 
			mainMap = new MapComponent({x:200, y:0}, {width:500, height:500}, data.myShip, 1/10, '#AED6F1', 'detailed', 'centered', 10, true, true); 
			miniMap = new MapComponent({x:200, y:0}, undefined, data.myShip, 1/100, 'black', 'dummy', 'whole', 0, false, false); 
			privateStatusBar = new PrivateStatusBar({x:0, y:0}, myStatus); 
			myStatusBar = new PublicStatusBar({x:100, y:0}, data.myShip.name); 
			enemyStatusBar = new PublicStatusBar({x:700, y:0}, undefined); 
			gameDiv.style.display = 'inline-block'; 
		} 
		else {alert(data.msg); }
	}); 
	
	// Update frame 
	socket.on('updateFrame', function(data){
		// data is composed of: 
		// a dictionary detectedShipList, with entries name:{position: {x, y}, bearing, components} 
		// a dictionary myShip = {currentSpeedFrac, currentRudderFrac} 
		// a dictionary enemyShip = {name} 
		
		// update 
		Mine.update(data.detectedMineList); 
		Torpedo.update(data.detectedTorpedoList); 
		Ship.update(data.detectedShipInfoList); 
		myStatus.update(data.myShip.currentSpeedFrac, data.myShip.currentRudderFrac); 
		myStatusBar.update(myStatus.name); 
		enemyStatusBar.update(data.enemyShip.name); 
		
		
		// draw 
		for(let i=0; i < CanvasComponent.list.length; i++) {
			CanvasComponent.list[i].draw(); 
		}
		ctx.setTransform(1, 0, 0, 1, 0, 0); 
	}); 
	
	// Control handling 
	document.onkeydown = function(event){
		if (event.keyCode === 65) {// On pressing 'a' 
			myStatus.rudderLock = 'left'; 
			socket.emit('rudderShift', 'left'); 
		} 
		else if (event.keyCode === 68) {
			myStatus.rudderLock = 'right'; 
			socket.emit('rudderShift', 'right'); 
		} 
		else if (event.keyCode === 81) {
			if (myStatus.rudderLock === 'right') {
				myStatus.rudderLock = 'straight'; 
				socket.emit('rudderShift', 'straight'); 
			}
			else {
				myStatus.rudderLock = 'left'; 
				socket.emit('rudderShift', 'left'); 
			}
		} 
		else if (event.keyCode === 69) {
			if (myStatus.rudderLock === 'left') {
				myStatus.rudderLock = 'straight'; 
				socket.emit('rudderShift', 'straight'); 
			}
			else {
				myStatus.rudderLock = 'right'; 
				socket.emit('rudderShift', 'right'); 
			}
		} 
		else if (event.keyCode === 87) {
			myStatus.speedLevelIndex = Math.min(myStatus.speedLevelIndex + 1, 3)
			socket.emit('speedChange', myStatus.speedLevels[myStatus.speedLevelIndex]); 
		} 
		else if (event.keyCode === 83) {
			myStatus.speedLevelIndex = Math.max(myStatus.speedLevelIndex - 1, 0)
			socket.emit('speedChange', myStatus.speedLevels[myStatus.speedLevelIndex]); 
		} 
		else if (event.keyCode === 88) {
			if (myStatus.name in Ship.list) {
				socket.emit('fireSelectedWeapon', {
					type:myStatus.weapons[myStatus.selectedWeaponIndex], 
					info:myStatus.getInfo()
				}); 
			}
		} 
		else if (event.keyCode > 48 && event.keyCode < 48 + myStatus.weapons.length) {
			myStatus.selectedWeaponIndex = event.keyCode - 48; 
		} 
		else if (event.keyCode === 16) {
			LMBStatus.shift = true; 
		} 
	}; 
	
	document.onkeyup = function(event){
		if (event.keyCode === 65) {
			myStatus.rudderLock = 'straight'; 
			socket.emit('rudderShift', 'straight'); 
		} 
		else if (event.keyCode === 68) {
			myStatus.rudderLock = 'straight'; 
			socket.emit('rudderShift', 'straight'); 
		} 
		else if (event.keyCode === 16) {
			LMBStatus.shift = false; 
		} 
	}; 
	
	document.onmousedown = function(event){
		LMBStatus.update(event.pageX - gameDiv.getBoundingClientRect().x, event.pageY - gameDiv.getBoundingClientRect().y, true); 
		for (let i = 0; i < CanvasComponent.list.length; i++) {
			CanvasComponent.list[i].onClick(LMBStatus.position, event); 
		}
	}; 
	
	document.onmouseup = function(event){
		LMBStatus.update(event.pageX - gameDiv.getBoundingClientRect().x, event.pageY - gameDiv.getBoundingClientRect().y, false); 
	}; 
	
	document.onmousemove = function(event){
		LMBStatus.update(event.pageX - gameDiv.getBoundingClientRect().x, event.pageY - gameDiv.getBoundingClientRect().y, LMBStatus.pressed); 
	}; 
</script>