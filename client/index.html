<div id="signUpDiv">
	name: <input id="signUpName" type="text"></input>
	<button id="signUpButton">Sign Up</button>
</div>

<div id="gameDiv" style="display:none;">
	<canvas id="ctx" width="800" height="500" style="border:1px solid #000000;"></canvas>
</div>

<script src="client/js/socket.io-1.4.5.js"></script>

<script>
	var socket = io(); 
	
	//Sign up 
	var signUpDiv = document.getElementById("signUpDiv"); 
	var signUpName = document.getElementById("signUpName"); 
	var signUpButton = document.getElementById("signUpButton"); 
	var gameDiv = document.getElementById("gameDiv"); 
	
	signUpButton.onclick = function(){
		socket.emit('signUp', {name:signUpName.value}); 
	}; 
	
	//Canvas setting 
	var wholeCanvas; 
	var mainMap; 
	var mapInfo; 
	var myStatusBar; 
	var enemyStatusBar; 
	var LMBStatus = {
		position: {x: 0, y: 0}, 
		pressed: false, 
		update: function(x, y, pressed) {this.position.x = x; this.position.y = y; this.pressed = pressed; }
	}; 
	
	var cvs = document.getElementById("ctx"); 
	var ctx = cvs.getContext("2d"); 
	ctx.font = '15px Arial'; 
	
	//Game objects 
	
	class Status {
		constructor() {
			this.speedLevels = ['reverse', 'stop', 'half', 'full']
			this.speedLevelIndex = 1; 
			this.rudderLock = 'straight'; // Can also take value 'left' or 'right', which evaluate to boolean true 
			this.currentSpeedFrac = 0; 
			this.currentRudderFrac = 0; 
			this.name = undefined; 
		}
		update(currentSpeedFrac, currentRudderFrac, name) {
			this.currentSpeedFrac = currentSpeedFrac; 
			this.currentRudderFrac = currentRudderFrac; 
			this.name = name; 
		}
	}; 
	var myStatus = new Status(); 
	var enemyStatus = new Status(); 
	
	class Entity {
		constructor(position, bearing) {
			this.position = position; 
			this.bearing = bearing; 
		}
		draw(scale) {}
		dummyDraw() {}
	}; 
	
	class Ship extends Entity {
		constructor(name, position, bearing, components) {
			super(position, bearing); 
			this.components = components; 
			this.name = name; // Maybe delete this 
		}
		update(position, bearing, components) {
			this.position = position; 
			this.bearing = bearing; 
			this.components = components; 
		}
		draw(scale, displayType, scopeType, displayFrameSize, myPosition, drawingMe, showName, bearingRelMyShip) {
			var drawShip = true; 
			if (scopeType === 'centered') {
				if (Math.abs(this.position.x-myPosition.x) > displayFrameSize.width/scale/2 && Math.abs(this.position.y-myPosition.y) <= displayFrameSize.height/scale/2) {
					drawShip = false; 
				}
			}
			if (drawShip) {
				if (displayType === 'detailed') {
					if (showName) {
						ctx.transform(1/scale, 0, 0, -1/scale, this.position.x, this.position.y); 
						ctx.fillStyle = 'black'; 
						ctx.fillText(this.name, -5, -15); 
						ctx.transform(scale, 0, 0, -scale, 0, 0); 
					}
					else {ctx.transform(1, 0, 0, 1, this.position.x, this.position.y); }
					
					if (bearingRelMyShip) {
						var relVectorLength = Math.sqrt((this.position.x - Ship.list[myStatus.name].position.x)*(this.position.x - Ship.list[myStatus.name].position.x) + (this.position.y - Ship.list[myStatus.name].position.y)*(this.position.y - Ship.list[myStatus.name].position.y)); 
						console.log(relVectorLength); 
						if (relVectorLength === 0) {
							ctx.transform(0, 1, -1, 0, 0, 0);
						}
						else {
							var relVectorCos = (this.position.x - Ship.list[myStatus.name].position.x)/relVectorLength; 
							var relVectorSin = (this.position.y - Ship.list[myStatus.name].position.y)/relVectorLength; 
							ctx.transform(Math.cos(this.bearing), Math.sin(this.bearing), -Math.sin(this.bearing), Math.cos(this.bearing), 0, 0); 
							ctx.transform(relVectorCos, -relVectorSin, relVectorSin, relVectorCos, 0, 0); 
							ctx.transform(0, 1, -1, 0, 0, 0); 
						}
					}
					else {ctx.transform(Math.cos(this.bearing), Math.sin(this.bearing), -Math.sin(this.bearing), Math.cos(this.bearing), 0, 0); } 
					for (let i = 0; i < this.components.length; i++) {
						ctx.fillStyle = 'black'; 
						if (this.components[i].shape.type === 'polygon') {
							ctx.transform(1, 0, 0, 1, this.components[i].position.x, this.components[i].position.y); 
							ctx.beginPath();
							ctx.moveTo(this.components[i].shape.vertices[0].x, this.components[i].shape.vertices[0].y); 
							for (let j = 1; j < this.components[i].shape.vertices.length; j++) {
								ctx.lineTo(this.components[i].shape.vertices[j].x, this.components[i].shape.vertices[j].y);
							}
							ctx.closePath(); 
							ctx.fill(); 
							ctx.transform(1, 0, 0, 1, -this.components[i].position.x, -this.components[i].position.y); 
						}
					}
				}
				else if (displayType === 'dummy') {
					if (drawingMe) {ctx.fillStyle = 'green'; }
					else {ctx.fillStyle = 'white'; }
					ctx.fillRect(this.position.x-2/scale, this.position.y-2/scale, 4/scale, 4/scale); 
				}
			}
		}
		static updateList(newShipList) {
			for(let shipName in Ship.list) {
				if (!(shipName in newShipList)){
					delete Ship.list[shipName]; 
				}
			}
			for(let shipName in newShipList) {
				if (shipName in Ship.list) {
					Ship.list[shipName].update(newShipList[shipName].position, newShipList[shipName].bearing, newShipList[shipName].components); 
				}
				else {
					var ship = new Ship(shipName, newShipList[shipName].position, newShipList[shipName].bearing, newShipList[shipName].components); 
					Ship.list[shipName] = ship; 
				}
			}
		}
	}; 
	Ship.list = {}; 
	
	//Canvas objects 
	
	class CanvasComponent {
		constructor(position, size, color) {
			CanvasComponent.list.push(this); 
			this.position = position; // position = {x, y} 
			this.size = size; // size = {width, height} 
			this.color = color; 
		}
		setTransform() {
			ctx.setTransform(1, 0, 0, 1, this.position.x, this.position.y); 
		} // set you up for drawing
		draw() { 
			ctx.fillStyle = this.color;
			ctx.setTransform(1, 0, 0, 1, 0, 0); 
			ctx.fillRect(this.position.x, this.position.y, this.size.width, this.size.height); // clear the component 
			this.setTransform(); 
		}
		isClickingMe(position) {
			if (position.x <= this.position.x) {
				return false; 
			}
			else if (position.x >= this.position.x + this.size.width) {
				return false; 
			}
			else if (position.y <= this.position.y) {
				return false; 
			}
			else if (position.y >= this.position.y + this.size.height) {
				return false; 
			}
			return true; 
		}
		onClick(position) {
			if (this.isClickingMe(position)) {
				// Do something 
			}
		}
	}; 
	CanvasComponent.list = []; // This is really a list, made to draw in the right order 
	
	class MapComponent extends CanvasComponent {
		constructor(position, size, myShip, scale, color, displayType, scopeType, grid, showName) {
			super(position, size, color); 
			if (scopeType === 'whole') {
				this.size = {width:mapInfo.size.x*scale, height:mapInfo.size.y*scale}; 
			}
			this.scale = scale; 
			this.myShipName = myShip.name; 
			this.myPosition = {x:mapInfo.size.x/2, y:mapInfo.size.y/2}; 
			this.displayType = displayType; 
			this.scopeType = scopeType; 
			this.grid = grid; 
			this.showName = showName; 
		}
		setTransform() {
			ctx.setTransform(this.scale, 0, 0, -this.scale, this.position.x + this.size.width/2, this.position.y + this.size.height/2);
			ctx.transform(1, 0, 0, 1, -this.myPosition.x, -this.myPosition.y);
		}
		drawGrid() {
			if (this.grid > 1) {
				this.setTransform(); 
				for(let i = Math.max(Math.ceil((this.myPosition.x - this.size.width/this.scale/2)/(mapInfo.size.x/this.grid))*(mapInfo.size.x/this.grid), 0); i <= Math.min((this.myPosition.x + this.size.width/this.scale/2), mapInfo.size.x); i += (mapInfo.size.x/this.grid)) {
					ctx.lineWidth=2/this.scale;
					ctx.strokeStyle="grey";
					ctx.beginPath();
					ctx.moveTo(i, Math.max(this.myPosition.y - this.size.height/this.scale/2, 0)); 
					ctx.lineTo(i, Math.min(this.myPosition.y + this.size.height/this.scale/2, mapInfo.size.y));
					ctx.stroke();
				}
				for(let i = Math.max(Math.ceil((this.myPosition.y - this.size.height/this.scale/2)/(mapInfo.size.y/this.grid))*(mapInfo.size.y/this.grid), 0); i <= Math.min((this.myPosition.y + this.size.height/this.scale/2), mapInfo.size.y); i += (mapInfo.size.y/this.grid)) {
					ctx.lineWidth=2/this.scale;
					ctx.strokeStyle="grey";
					ctx.beginPath();
					ctx.moveTo(Math.max(this.myPosition.x - this.size.width/this.scale/2, 0), i); 
					ctx.lineTo(Math.min(this.myPosition.x + this.size.width/this.scale/2, mapInfo.size.x), i);
					ctx.stroke();
				}
			}
		}
		draw() {
			super.draw(); 
			if (this.scopeType === 'centered') {this.myPosition = Ship.list[this.myShipName].position; } 
			
			//draw grid 
			this.drawGrid(); 
			
			//draw ships 
			for(let name in Ship.list) {
				this.setTransform(); 
				Ship.list[name].draw(this.scale, this.displayType, this.scopeType, this.size, this.myPosition, (name === this.myShipName), this.showName); 
			}
		}
		onClick(position) {
			if (this.isClickingMe(position)) {
				var positionInMap = {x:position.x, y:position.y}; 
				positionInMap.x -= (this.position.x + this.size.width/2); 
				positionInMap.y = this.position.y - positionInMap.y + this.size.height/2; 
				positionInMap.x /= this.scale; 
				positionInMap.y /= this.scale; 
				positionInMap.x += this.myPosition.x; 
				positionInMap.y += this.myPosition.y; 
				console.log(positionInMap.x + ' ' + positionInMap.y); 
			
			var closestShipName = undefined; 
			var minDistanceSquared = mapInfo.size.x*mapInfo.size.x + mapInfo.size.y*mapInfo.size.y; 
			for (let shipName in Ship.list) {
				var currentDistanceSquared = (Ship.list[shipName].position.x - positionInMap.x)*(Ship.list[shipName].position.x - positionInMap.x) + (Ship.list[shipName].position.y - positionInMap.y)*(Ship.list[shipName].position.y - positionInMap.y); 
				if ((closestShipName === undefined || currentDistanceSquared < minDistanceSquared) && shipName != this.myShipName) {
					minDistanceSquared = currentDistanceSquared; 
					closestShipName = shipName; 
				}
			}
			socket.emit('selectEnemy', closestShipName); 
			console.log(closestShipName); 
			console.log(myStatus.rudderLock); 
			}
		}
	}; 
	
	class NameBar extends CanvasComponent {
		constructor(position, status) {
			super(position, {width: 100, height: 20}, 'grey'); 
			this.status = status; 
		}
		draw() {
			super.draw(); 
			ctx.fillStyle = 'black'; 
			if (this.status.name) {ctx.fillText(this.status.name, 5, this.size.height); } 
		}
	}; 
	
	class ShipGraph extends CanvasComponent {
		constructor(position, status) {
			super(position, {width: 100, height: 100}, 'grey'); 
			this.status = status; 
			this.scale = 0.2; 
		}
		setTransform() {
			ctx.setTransform(this.scale, 0, 0, -this.scale, this.position.x + this.size.width/2, this.position.y + this.size.height/2); 
			ctx.transform(1, 0, 0, 1, -Ship.list[this.status.name].position.x, -Ship.list[this.status.name].position.y); 
		} 
		draw() {
			if (this.status.name != undefined) {
				super.draw(); 
				Ship.list[this.status.name].draw(this.scale, 'detailed', undefined, undefined, undefined, undefined, false, true); 
			}
		}
	}; 
	
	class SpeedBar extends CanvasComponent {
		constructor(position, status) {
			super(position, {width:100, height:100}, 'white')
			this.rudderLockDic = {'left': -this.size.width/2, 'straight': 0, 'right': this.size.width/2}; 
			this.speedLockDic = {'full': 4*this.size.height/5, 'half': 2*this.size.height/5, 'stop': 0, 'reverse': -this.size.height/5}; 
			this.status = status; 
		}
		setTransform() {
			ctx.setTransform(1, 0, 0, -1, this.position.x + this.size.width/2, this.position.y + 4*this.size.height/5); 
		} // set you up for drawing
		draw() {
			super.draw(); 
			ctx.strokeStyle="black";
			ctx.lineWidth=5;
			ctx.beginPath();
			ctx.moveTo(this.rudderLockDic['left'], 0); 
			ctx.lineTo(this.rudderLockDic['right'], 0);
			ctx.stroke();
			ctx.beginPath();
			ctx.moveTo(0, this.speedLockDic['full']); 
			ctx.lineTo(0, this.speedLockDic['reverse']);
			ctx.stroke();
			ctx.fillStyle = 'red';
			ctx.fillRect(this.rudderLockDic[this.status.rudderLock]-5, this.speedLockDic[this.status.speedLevels[this.status.speedLevelIndex]]-5, 10, 10); 
			ctx.fillStyle = 'blue';
			ctx.fillRect(this.rudderLockDic['left']*this.status.currentRudderFrac-5, this.speedLockDic['full']*this.status.currentSpeedFrac-5, 10, 10); 
		}
	}; 
	
	class StatusBar extends CanvasComponent {
		constructor(position, status) {
			super(position, {width:100, height:500}, 'grey'); 
			this.status = status; 
			this.bars = []; 
			this.bars.push(new NameBar({x:this.position.x, y:this.position.y}, this.status)); 
			this.bars.push(new ShipGraph({x:this.position.x, y:this.position.y + 20}, this.status)); 
		}
		draw() {
			super.draw(); 
			for (let i = 0; i < this.bars.length; i++) {
				this.bars[i].draw(); 
			}
		}
	}; 
	
	// Socket package handling 
	// Signup response 
	socket.on('signUpResponse', function(data){
		if (data.success){
			signUpDiv.style.display = 'none'; 
			mapInfo = data.mapInfo; 
			wholeCanvas = new CanvasComponent({x:0,y:0}, {width:800, height:500}, 'white'); 
			myStatus = new Status(); 
			myStatus.name = data.myShip.name; 
			myStatusBar = new StatusBar({x:100, y:0}, myStatus); 
			myStatusBar.bars.push(new SpeedBar({x:myStatusBar.position.x, y:myStatusBar.position.y+350}, myStatusBar.status)); 
			enemyStatusBar = new StatusBar({x:700, y:0}, enemyStatus); 
			mainMap = new MapComponent({x:200, y:0}, {width:500, height:500}, data.myShip, 1/10, '#AED6F1', 'detailed', 'centered', 10, true, false); 
			miniMap = new MapComponent({x:200, y:0}, undefined, data.myShip, 1/100, 'black', 'dummy', 'whole', 0, false, undefined); 
			gameDiv.style.display = 'inline-block'; 
		} 
		else {alert(data.msg); }
	}); 
	
	// Update frame 
	socket.on('updateFrame', function(data){
		// data is composed of: 
		// a dictionary detectedShipList, with entries name:{position: {x, y}, bearing, components} 
		// a dictionary myShip = {currentSpeedFrac, currentRudderFrac} 
		
		// update 
		myStatus.update(data.myShip.currentSpeedFrac, data.myShip.currentRudderFrac, myStatus.name); 
		enemyStatus.update(0, 0, data.enemyShip.name); 
		Ship.updateList(data.detectedShipInfoList); 
		
		// draw 
		for(let i=0; i < CanvasComponent.list.length; i++) {
			CanvasComponent.list[i].draw(); 
		}
		ctx.setTransform(1, 0, 0, 1, 0, 0); 
	}); 
	
	// Control handling 
	document.onkeydown = function(event){
		if (event.keyCode === 65) {// On pressing 'a' 
			myStatus.rudderLock = 'left'; 
			socket.emit('rudderShift', 'left'); 
		} 
		else if (event.keyCode === 68) {
			myStatus.rudderLock = 'right'; 
			socket.emit('rudderShift', 'right'); 
		} 
		else if (event.keyCode === 81) {
			if (myStatus.rudderLock === 'right') {
				myStatus.rudderLock = 'straight'; 
				socket.emit('rudderShift', 'straight'); 
			}
			else {
				myStatus.rudderLock = 'left'; 
				socket.emit('rudderShift', 'left'); 
			}
		} 
		else if (event.keyCode === 69) {
			if (myStatus.rudderLock === 'left') {
				myStatus.rudderLock = 'straight'; 
				socket.emit('rudderShift', 'straight'); 
			}
			else {
				myStatus.rudderLock = 'right'; 
				socket.emit('rudderShift', 'right'); 
			}
		} 
		else if (event.keyCode === 87) {
			myStatus.speedLevelIndex = Math.min(myStatus.speedLevelIndex + 1, 3)
			socket.emit('speedChange', myStatus.speedLevels[myStatus.speedLevelIndex]); 
		} 
		else if (event.keyCode === 83) {
			myStatus.speedLevelIndex = Math.max(myStatus.speedLevelIndex - 1, 0)
			socket.emit('speedChange', myStatus.speedLevels[myStatus.speedLevelIndex]); 
		} 
	}; 
	
	document.onkeyup = function(event){
		if (event.keyCode === 65) {
			myStatus.rudderLock = 'straight'; 
			socket.emit('rudderShift', 'straight'); 
		} 
		else if (event.keyCode === 68) {
			myStatus.rudderLock = 'straight'; 
			socket.emit('rudderShift', 'straight'); 
		} 
	}; 
	
	document.onmousedown = function(event){
		LMBStatus.update(event.pageX, event.pageY, true); 
		for (let i = 0; i < CanvasComponent.list.length; i++) {
			CanvasComponent.list[i].onClick(LMBStatus.position); 
		}
	}; 
	
	document.onmouseup = function(event){
		LMBStatus.update(event.pageX, event.pageY, false); 
	}; 
</script>